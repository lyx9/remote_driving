// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fsm_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fsm_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fsm_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fsm_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fsm_5fmessages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fsm_5fmessages_2eproto;
namespace fsm {
namespace proto {
class Alert;
class AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class ConnectionStatus;
class ConnectionStatusDefaultTypeInternal;
extern ConnectionStatusDefaultTypeInternal _ConnectionStatus_default_instance_;
class ControlCommand;
class ControlCommandDefaultTypeInternal;
extern ControlCommandDefaultTypeInternal _ControlCommand_default_instance_;
class DiagnosticStatus;
class DiagnosticStatusDefaultTypeInternal;
extern DiagnosticStatusDefaultTypeInternal _DiagnosticStatus_default_instance_;
class EmergencyCommand;
class EmergencyCommandDefaultTypeInternal;
extern EmergencyCommandDefaultTypeInternal _EmergencyCommand_default_instance_;
class GearCommand;
class GearCommandDefaultTypeInternal;
extern GearCommandDefaultTypeInternal _GearCommand_default_instance_;
class GeoPoint;
class GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class Heartbeat;
class HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class HeartbeatAck;
class HeartbeatAckDefaultTypeInternal;
extern HeartbeatAckDefaultTypeInternal _HeartbeatAck_default_instance_;
class LatencyCompensation;
class LatencyCompensationDefaultTypeInternal;
extern LatencyCompensationDefaultTypeInternal _LatencyCompensation_default_instance_;
class LatencyInfo;
class LatencyInfoDefaultTypeInternal;
extern LatencyInfoDefaultTypeInternal _LatencyInfo_default_instance_;
class LocalizationState;
class LocalizationStateDefaultTypeInternal;
extern LocalizationStateDefaultTypeInternal _LocalizationState_default_instance_;
class LongitudinalCommand;
class LongitudinalCommandDefaultTypeInternal;
extern LongitudinalCommandDefaultTypeInternal _LongitudinalCommand_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PredictedTrajectory;
class PredictedTrajectoryDefaultTypeInternal;
extern PredictedTrajectoryDefaultTypeInternal _PredictedTrajectory_default_instance_;
class PredictedTrajectoryPoint;
class PredictedTrajectoryPointDefaultTypeInternal;
extern PredictedTrajectoryPointDefaultTypeInternal _PredictedTrajectoryPoint_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class SchedulingQueue;
class SchedulingQueueDefaultTypeInternal;
extern SchedulingQueueDefaultTypeInternal _SchedulingQueue_default_instance_;
class SteeringCommand;
class SteeringCommandDefaultTypeInternal;
extern SteeringCommandDefaultTypeInternal _SteeringCommand_default_instance_;
class SteeringStatus;
class SteeringStatusDefaultTypeInternal;
extern SteeringStatusDefaultTypeInternal _SteeringStatus_default_instance_;
class SystemStatus;
class SystemStatusDefaultTypeInternal;
extern SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
class TelemetryData;
class TelemetryDataDefaultTypeInternal;
extern TelemetryDataDefaultTypeInternal _TelemetryData_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TurnSignalCommand;
class TurnSignalCommandDefaultTypeInternal;
extern TurnSignalCommandDefaultTypeInternal _TurnSignalCommand_default_instance_;
class Twist;
class TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class VehicleSchedulingInfo;
class VehicleSchedulingInfoDefaultTypeInternal;
extern VehicleSchedulingInfoDefaultTypeInternal _VehicleSchedulingInfo_default_instance_;
class VehicleStatus;
class VehicleStatusDefaultTypeInternal;
extern VehicleStatusDefaultTypeInternal _VehicleStatus_default_instance_;
class VelocityStatus;
class VelocityStatusDefaultTypeInternal;
extern VelocityStatusDefaultTypeInternal _VelocityStatus_default_instance_;
class VideoFrameMetadata;
class VideoFrameMetadataDefaultTypeInternal;
extern VideoFrameMetadataDefaultTypeInternal _VideoFrameMetadata_default_instance_;
}  // namespace proto
}  // namespace fsm
PROTOBUF_NAMESPACE_OPEN
template<> ::fsm::proto::Alert* Arena::CreateMaybeMessage<::fsm::proto::Alert>(Arena*);
template<> ::fsm::proto::ConnectionStatus* Arena::CreateMaybeMessage<::fsm::proto::ConnectionStatus>(Arena*);
template<> ::fsm::proto::ControlCommand* Arena::CreateMaybeMessage<::fsm::proto::ControlCommand>(Arena*);
template<> ::fsm::proto::DiagnosticStatus* Arena::CreateMaybeMessage<::fsm::proto::DiagnosticStatus>(Arena*);
template<> ::fsm::proto::EmergencyCommand* Arena::CreateMaybeMessage<::fsm::proto::EmergencyCommand>(Arena*);
template<> ::fsm::proto::GearCommand* Arena::CreateMaybeMessage<::fsm::proto::GearCommand>(Arena*);
template<> ::fsm::proto::GeoPoint* Arena::CreateMaybeMessage<::fsm::proto::GeoPoint>(Arena*);
template<> ::fsm::proto::Heartbeat* Arena::CreateMaybeMessage<::fsm::proto::Heartbeat>(Arena*);
template<> ::fsm::proto::HeartbeatAck* Arena::CreateMaybeMessage<::fsm::proto::HeartbeatAck>(Arena*);
template<> ::fsm::proto::LatencyCompensation* Arena::CreateMaybeMessage<::fsm::proto::LatencyCompensation>(Arena*);
template<> ::fsm::proto::LatencyInfo* Arena::CreateMaybeMessage<::fsm::proto::LatencyInfo>(Arena*);
template<> ::fsm::proto::LocalizationState* Arena::CreateMaybeMessage<::fsm::proto::LocalizationState>(Arena*);
template<> ::fsm::proto::LongitudinalCommand* Arena::CreateMaybeMessage<::fsm::proto::LongitudinalCommand>(Arena*);
template<> ::fsm::proto::Pose* Arena::CreateMaybeMessage<::fsm::proto::Pose>(Arena*);
template<> ::fsm::proto::PredictedTrajectory* Arena::CreateMaybeMessage<::fsm::proto::PredictedTrajectory>(Arena*);
template<> ::fsm::proto::PredictedTrajectoryPoint* Arena::CreateMaybeMessage<::fsm::proto::PredictedTrajectoryPoint>(Arena*);
template<> ::fsm::proto::Quaternion* Arena::CreateMaybeMessage<::fsm::proto::Quaternion>(Arena*);
template<> ::fsm::proto::SchedulingQueue* Arena::CreateMaybeMessage<::fsm::proto::SchedulingQueue>(Arena*);
template<> ::fsm::proto::SteeringCommand* Arena::CreateMaybeMessage<::fsm::proto::SteeringCommand>(Arena*);
template<> ::fsm::proto::SteeringStatus* Arena::CreateMaybeMessage<::fsm::proto::SteeringStatus>(Arena*);
template<> ::fsm::proto::SystemStatus* Arena::CreateMaybeMessage<::fsm::proto::SystemStatus>(Arena*);
template<> ::fsm::proto::TelemetryData* Arena::CreateMaybeMessage<::fsm::proto::TelemetryData>(Arena*);
template<> ::fsm::proto::Timestamp* Arena::CreateMaybeMessage<::fsm::proto::Timestamp>(Arena*);
template<> ::fsm::proto::TurnSignalCommand* Arena::CreateMaybeMessage<::fsm::proto::TurnSignalCommand>(Arena*);
template<> ::fsm::proto::Twist* Arena::CreateMaybeMessage<::fsm::proto::Twist>(Arena*);
template<> ::fsm::proto::Vector3* Arena::CreateMaybeMessage<::fsm::proto::Vector3>(Arena*);
template<> ::fsm::proto::VehicleSchedulingInfo* Arena::CreateMaybeMessage<::fsm::proto::VehicleSchedulingInfo>(Arena*);
template<> ::fsm::proto::VehicleStatus* Arena::CreateMaybeMessage<::fsm::proto::VehicleStatus>(Arena*);
template<> ::fsm::proto::VelocityStatus* Arena::CreateMaybeMessage<::fsm::proto::VelocityStatus>(Arena*);
template<> ::fsm::proto::VideoFrameMetadata* Arena::CreateMaybeMessage<::fsm::proto::VideoFrameMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fsm {
namespace proto {

enum ConnectionStatus_State : int {
  ConnectionStatus_State_DISCONNECTED = 0,
  ConnectionStatus_State_CONNECTING = 1,
  ConnectionStatus_State_CONNECTED = 2,
  ConnectionStatus_State_RECONNECTING = 3,
  ConnectionStatus_State_FAILED = 4,
  ConnectionStatus_State_ConnectionStatus_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConnectionStatus_State_ConnectionStatus_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConnectionStatus_State_IsValid(int value);
constexpr ConnectionStatus_State ConnectionStatus_State_State_MIN = ConnectionStatus_State_DISCONNECTED;
constexpr ConnectionStatus_State ConnectionStatus_State_State_MAX = ConnectionStatus_State_FAILED;
constexpr int ConnectionStatus_State_State_ARRAYSIZE = ConnectionStatus_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionStatus_State_descriptor();
template<typename T>
inline const std::string& ConnectionStatus_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionStatus_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionStatus_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionStatus_State_descriptor(), enum_t_value);
}
inline bool ConnectionStatus_State_Parse(
    const std::string& name, ConnectionStatus_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionStatus_State>(
    ConnectionStatus_State_descriptor(), name, value);
}
enum GearPosition : int {
  GEAR_PARK = 0,
  GEAR_REVERSE = 1,
  GEAR_NEUTRAL = 2,
  GEAR_DRIVE = 3,
  GEAR_LOW = 4,
  GearPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GearPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GearPosition_IsValid(int value);
constexpr GearPosition GearPosition_MIN = GEAR_PARK;
constexpr GearPosition GearPosition_MAX = GEAR_LOW;
constexpr int GearPosition_ARRAYSIZE = GearPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GearPosition_descriptor();
template<typename T>
inline const std::string& GearPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GearPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GearPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GearPosition_descriptor(), enum_t_value);
}
inline bool GearPosition_Parse(
    const std::string& name, GearPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GearPosition>(
    GearPosition_descriptor(), name, value);
}
enum VehicleMode : int {
  MODE_MANUAL = 0,
  MODE_AUTONOMOUS = 1,
  MODE_REMOTE = 2,
  MODE_EMERGENCY = 3,
  VehicleMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VehicleMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VehicleMode_IsValid(int value);
constexpr VehicleMode VehicleMode_MIN = MODE_MANUAL;
constexpr VehicleMode VehicleMode_MAX = MODE_EMERGENCY;
constexpr int VehicleMode_ARRAYSIZE = VehicleMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleMode_descriptor();
template<typename T>
inline const std::string& VehicleMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleMode_descriptor(), enum_t_value);
}
inline bool VehicleMode_Parse(
    const std::string& name, VehicleMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleMode>(
    VehicleMode_descriptor(), name, value);
}
enum TurnSignal : int {
  SIGNAL_NONE = 0,
  SIGNAL_LEFT = 1,
  SIGNAL_RIGHT = 2,
  SIGNAL_HAZARD = 3,
  TurnSignal_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TurnSignal_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TurnSignal_IsValid(int value);
constexpr TurnSignal TurnSignal_MIN = SIGNAL_NONE;
constexpr TurnSignal TurnSignal_MAX = SIGNAL_HAZARD;
constexpr int TurnSignal_ARRAYSIZE = TurnSignal_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TurnSignal_descriptor();
template<typename T>
inline const std::string& TurnSignal_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TurnSignal>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TurnSignal_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TurnSignal_descriptor(), enum_t_value);
}
inline bool TurnSignal_Parse(
    const std::string& name, TurnSignal* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TurnSignal>(
    TurnSignal_descriptor(), name, value);
}
enum DiagnosticLevel : int {
  DIAG_OK = 0,
  DIAG_WARN = 1,
  DIAG_ERROR = 2,
  DIAG_STALE = 3,
  DiagnosticLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DiagnosticLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DiagnosticLevel_IsValid(int value);
constexpr DiagnosticLevel DiagnosticLevel_MIN = DIAG_OK;
constexpr DiagnosticLevel DiagnosticLevel_MAX = DIAG_STALE;
constexpr int DiagnosticLevel_ARRAYSIZE = DiagnosticLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DiagnosticLevel_descriptor();
template<typename T>
inline const std::string& DiagnosticLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DiagnosticLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DiagnosticLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DiagnosticLevel_descriptor(), enum_t_value);
}
inline bool DiagnosticLevel_Parse(
    const std::string& name, DiagnosticLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DiagnosticLevel>(
    DiagnosticLevel_descriptor(), name, value);
}
enum VehicleTaskStatus : int {
  TASK_IDLE = 0,
  TASK_ACTIVE = 1,
  TASK_PAUSED = 2,
  TASK_COMPLETED = 3,
  TASK_FAILED = 4,
  VehicleTaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VehicleTaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VehicleTaskStatus_IsValid(int value);
constexpr VehicleTaskStatus VehicleTaskStatus_MIN = TASK_IDLE;
constexpr VehicleTaskStatus VehicleTaskStatus_MAX = TASK_FAILED;
constexpr int VehicleTaskStatus_ARRAYSIZE = VehicleTaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleTaskStatus_descriptor();
template<typename T>
inline const std::string& VehicleTaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleTaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleTaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleTaskStatus_descriptor(), enum_t_value);
}
inline bool VehicleTaskStatus_Parse(
    const std::string& name, VehicleTaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleTaskStatus>(
    VehicleTaskStatus_descriptor(), name, value);
}
enum EmergencyLevel : int {
  EMERGENCY_NONE = 0,
  EMERGENCY_LOW = 1,
  EMERGENCY_MEDIUM = 2,
  EMERGENCY_HIGH = 3,
  EMERGENCY_CRITICAL = 4,
  EmergencyLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EmergencyLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EmergencyLevel_IsValid(int value);
constexpr EmergencyLevel EmergencyLevel_MIN = EMERGENCY_NONE;
constexpr EmergencyLevel EmergencyLevel_MAX = EMERGENCY_CRITICAL;
constexpr int EmergencyLevel_ARRAYSIZE = EmergencyLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmergencyLevel_descriptor();
template<typename T>
inline const std::string& EmergencyLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmergencyLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmergencyLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmergencyLevel_descriptor(), enum_t_value);
}
inline bool EmergencyLevel_Parse(
    const std::string& name, EmergencyLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmergencyLevel>(
    EmergencyLevel_descriptor(), name, value);
}
enum AlertSeverity : int {
  ALERT_INFO = 0,
  ALERT_WARNING = 1,
  ALERT_ERROR = 2,
  ALERT_CRITICAL = 3,
  AlertSeverity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AlertSeverity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AlertSeverity_IsValid(int value);
constexpr AlertSeverity AlertSeverity_MIN = ALERT_INFO;
constexpr AlertSeverity AlertSeverity_MAX = ALERT_CRITICAL;
constexpr int AlertSeverity_ARRAYSIZE = AlertSeverity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlertSeverity_descriptor();
template<typename T>
inline const std::string& AlertSeverity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlertSeverity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlertSeverity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlertSeverity_descriptor(), enum_t_value);
}
inline bool AlertSeverity_Parse(
    const std::string& name, AlertSeverity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlertSeverity>(
    AlertSeverity_descriptor(), name, value);
}
enum AlertType : int {
  ALERT_LATENCY = 0,
  ALERT_CONNECTION = 1,
  ALERT_VEHICLE = 2,
  ALERT_SYSTEM = 3,
  ALERT_SAFETY = 4,
  AlertType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AlertType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AlertType_IsValid(int value);
constexpr AlertType AlertType_MIN = ALERT_LATENCY;
constexpr AlertType AlertType_MAX = ALERT_SAFETY;
constexpr int AlertType_ARRAYSIZE = AlertType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlertType_descriptor();
template<typename T>
inline const std::string& AlertType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlertType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlertType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlertType_descriptor(), enum_t_value);
}
inline bool AlertType_Parse(
    const std::string& name, AlertType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlertType>(
    AlertType_descriptor(), name, value);
}
// ===================================================================

class Timestamp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {};
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // int64 seconds = 1;
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::int64 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 nanos = 2;
  void clear_nanos();
  ::PROTOBUF_NAMESPACE_ID::int32 nanos() const;
  void set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nanos() const;
  void _internal_set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 nanos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Vector3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {};
  virtual ~Vector3();

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(nullptr);
  }

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Quaternion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {};
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double w = 4;
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  double w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class GeoPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {};
  virtual ~GeoPoint();

  GeoPoint(const GeoPoint& from);
  GeoPoint(GeoPoint&& from) noexcept
    : GeoPoint() {
    *this = ::std::move(from);
  }

  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
               &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GeoPoint& a, GeoPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPoint* New() const final {
    return CreateMaybeMessage<GeoPoint>(nullptr);
  }

  GeoPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPoint& from);
  void MergeFrom(const GeoPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.GeoPoint";
  }
  protected:
  explicit GeoPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kAltitudeFieldNumber = 3,
  };
  // double latitude = 1;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 2;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double altitude = 3;
  void clear_altitude();
  double altitude() const;
  void set_altitude(double value);
  private:
  double _internal_altitude() const;
  void _internal_set_altitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.GeoPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double latitude_;
  double longitude_;
  double altitude_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VelocityStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.VelocityStatus) */ {
 public:
  inline VelocityStatus() : VelocityStatus(nullptr) {};
  virtual ~VelocityStatus();

  VelocityStatus(const VelocityStatus& from);
  VelocityStatus(VelocityStatus&& from) noexcept
    : VelocityStatus() {
    *this = ::std::move(from);
  }

  inline VelocityStatus& operator=(const VelocityStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VelocityStatus& operator=(VelocityStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VelocityStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VelocityStatus* internal_default_instance() {
    return reinterpret_cast<const VelocityStatus*>(
               &_VelocityStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VelocityStatus& a, VelocityStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VelocityStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VelocityStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VelocityStatus* New() const final {
    return CreateMaybeMessage<VelocityStatus>(nullptr);
  }

  VelocityStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VelocityStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VelocityStatus& from);
  void MergeFrom(const VelocityStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VelocityStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.VelocityStatus";
  }
  protected:
  explicit VelocityStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kLongitudinalVelocityFieldNumber = 2,
    kLateralVelocityFieldNumber = 3,
    kHeadingRateFieldNumber = 4,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float longitudinal_velocity = 2;
  void clear_longitudinal_velocity();
  float longitudinal_velocity() const;
  void set_longitudinal_velocity(float value);
  private:
  float _internal_longitudinal_velocity() const;
  void _internal_set_longitudinal_velocity(float value);
  public:

  // float lateral_velocity = 3;
  void clear_lateral_velocity();
  float lateral_velocity() const;
  void set_lateral_velocity(float value);
  private:
  float _internal_lateral_velocity() const;
  void _internal_set_lateral_velocity(float value);
  public:

  // float heading_rate = 4;
  void clear_heading_rate();
  float heading_rate() const;
  void set_heading_rate(float value);
  private:
  float _internal_heading_rate() const;
  void _internal_set_heading_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.VelocityStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  float longitudinal_velocity_;
  float lateral_velocity_;
  float heading_rate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SteeringStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.SteeringStatus) */ {
 public:
  inline SteeringStatus() : SteeringStatus(nullptr) {};
  virtual ~SteeringStatus();

  SteeringStatus(const SteeringStatus& from);
  SteeringStatus(SteeringStatus&& from) noexcept
    : SteeringStatus() {
    *this = ::std::move(from);
  }

  inline SteeringStatus& operator=(const SteeringStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteeringStatus& operator=(SteeringStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SteeringStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SteeringStatus* internal_default_instance() {
    return reinterpret_cast<const SteeringStatus*>(
               &_SteeringStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SteeringStatus& a, SteeringStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SteeringStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SteeringStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SteeringStatus* New() const final {
    return CreateMaybeMessage<SteeringStatus>(nullptr);
  }

  SteeringStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SteeringStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SteeringStatus& from);
  void MergeFrom(const SteeringStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteeringStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.SteeringStatus";
  }
  protected:
  explicit SteeringStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kSteeringTireAngleFieldNumber = 2,
    kSteeringWheelAngleFieldNumber = 3,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float steering_tire_angle = 2;
  void clear_steering_tire_angle();
  float steering_tire_angle() const;
  void set_steering_tire_angle(float value);
  private:
  float _internal_steering_tire_angle() const;
  void _internal_set_steering_tire_angle(float value);
  public:

  // float steering_wheel_angle = 3;
  void clear_steering_wheel_angle();
  float steering_wheel_angle() const;
  void set_steering_wheel_angle(float value);
  private:
  float _internal_steering_wheel_angle() const;
  void _internal_set_steering_wheel_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.SteeringStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  float steering_tire_angle_;
  float steering_wheel_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VehicleStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.VehicleStatus) */ {
 public:
  inline VehicleStatus() : VehicleStatus(nullptr) {};
  virtual ~VehicleStatus();

  VehicleStatus(const VehicleStatus& from);
  VehicleStatus(VehicleStatus&& from) noexcept
    : VehicleStatus() {
    *this = ::std::move(from);
  }

  inline VehicleStatus& operator=(const VehicleStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleStatus& operator=(VehicleStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleStatus* internal_default_instance() {
    return reinterpret_cast<const VehicleStatus*>(
               &_VehicleStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VehicleStatus& a, VehicleStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleStatus* New() const final {
    return CreateMaybeMessage<VehicleStatus>(nullptr);
  }

  VehicleStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleStatus& from);
  void MergeFrom(const VehicleStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.VehicleStatus";
  }
  protected:
  explicit VehicleStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdFieldNumber = 2,
    kStampFieldNumber = 1,
    kVelocityFieldNumber = 3,
    kSteeringFieldNumber = 4,
    kGearFieldNumber = 5,
    kModeFieldNumber = 6,
    kTurnSignalFieldNumber = 7,
    kHazardLightsFieldNumber = 8,
    kHeadlightsFieldNumber = 9,
    kFuelLevelFieldNumber = 10,
    kBatteryLevelFieldNumber = 11,
  };
  // string vehicle_id = 2;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.VelocityStatus velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::fsm::proto::VelocityStatus& velocity() const;
  ::fsm::proto::VelocityStatus* release_velocity();
  ::fsm::proto::VelocityStatus* mutable_velocity();
  void set_allocated_velocity(::fsm::proto::VelocityStatus* velocity);
  private:
  const ::fsm::proto::VelocityStatus& _internal_velocity() const;
  ::fsm::proto::VelocityStatus* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::fsm::proto::VelocityStatus* velocity);
  ::fsm::proto::VelocityStatus* unsafe_arena_release_velocity();

  // .fsm.proto.SteeringStatus steering = 4;
  bool has_steering() const;
  private:
  bool _internal_has_steering() const;
  public:
  void clear_steering();
  const ::fsm::proto::SteeringStatus& steering() const;
  ::fsm::proto::SteeringStatus* release_steering();
  ::fsm::proto::SteeringStatus* mutable_steering();
  void set_allocated_steering(::fsm::proto::SteeringStatus* steering);
  private:
  const ::fsm::proto::SteeringStatus& _internal_steering() const;
  ::fsm::proto::SteeringStatus* _internal_mutable_steering();
  public:
  void unsafe_arena_set_allocated_steering(
      ::fsm::proto::SteeringStatus* steering);
  ::fsm::proto::SteeringStatus* unsafe_arena_release_steering();

  // .fsm.proto.GearPosition gear = 5;
  void clear_gear();
  ::fsm::proto::GearPosition gear() const;
  void set_gear(::fsm::proto::GearPosition value);
  private:
  ::fsm::proto::GearPosition _internal_gear() const;
  void _internal_set_gear(::fsm::proto::GearPosition value);
  public:

  // .fsm.proto.VehicleMode mode = 6;
  void clear_mode();
  ::fsm::proto::VehicleMode mode() const;
  void set_mode(::fsm::proto::VehicleMode value);
  private:
  ::fsm::proto::VehicleMode _internal_mode() const;
  void _internal_set_mode(::fsm::proto::VehicleMode value);
  public:

  // .fsm.proto.TurnSignal turn_signal = 7;
  void clear_turn_signal();
  ::fsm::proto::TurnSignal turn_signal() const;
  void set_turn_signal(::fsm::proto::TurnSignal value);
  private:
  ::fsm::proto::TurnSignal _internal_turn_signal() const;
  void _internal_set_turn_signal(::fsm::proto::TurnSignal value);
  public:

  // bool hazard_lights = 8;
  void clear_hazard_lights();
  bool hazard_lights() const;
  void set_hazard_lights(bool value);
  private:
  bool _internal_hazard_lights() const;
  void _internal_set_hazard_lights(bool value);
  public:

  // bool headlights = 9;
  void clear_headlights();
  bool headlights() const;
  void set_headlights(bool value);
  private:
  bool _internal_headlights() const;
  void _internal_set_headlights(bool value);
  public:

  // float fuel_level = 10;
  void clear_fuel_level();
  float fuel_level() const;
  void set_fuel_level(float value);
  private:
  float _internal_fuel_level() const;
  void _internal_set_fuel_level(float value);
  public:

  // float battery_level = 11;
  void clear_battery_level();
  float battery_level() const;
  void set_battery_level(float value);
  private:
  float _internal_battery_level() const;
  void _internal_set_battery_level(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.VehicleStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::VelocityStatus* velocity_;
  ::fsm::proto::SteeringStatus* steering_;
  int gear_;
  int mode_;
  int turn_signal_;
  bool hazard_lights_;
  bool headlights_;
  float fuel_level_;
  float battery_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Pose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {};
  virtual ~Pose();

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(nullptr);
  }

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // .fsm.proto.Vector3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::fsm::proto::Vector3& position() const;
  ::fsm::proto::Vector3* release_position();
  ::fsm::proto::Vector3* mutable_position();
  void set_allocated_position(::fsm::proto::Vector3* position);
  private:
  const ::fsm::proto::Vector3& _internal_position() const;
  ::fsm::proto::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::fsm::proto::Vector3* position);
  ::fsm::proto::Vector3* unsafe_arena_release_position();

  // .fsm.proto.Quaternion orientation = 2;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::fsm::proto::Quaternion& orientation() const;
  ::fsm::proto::Quaternion* release_orientation();
  ::fsm::proto::Quaternion* mutable_orientation();
  void set_allocated_orientation(::fsm::proto::Quaternion* orientation);
  private:
  const ::fsm::proto::Quaternion& _internal_orientation() const;
  ::fsm::proto::Quaternion* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::fsm::proto::Quaternion* orientation);
  ::fsm::proto::Quaternion* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:fsm.proto.Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Vector3* position_;
  ::fsm::proto::Quaternion* orientation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Twist PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Twist) */ {
 public:
  inline Twist() : Twist(nullptr) {};
  virtual ~Twist();

  Twist(const Twist& from);
  Twist(Twist&& from) noexcept
    : Twist() {
    *this = ::std::move(from);
  }

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twist& operator=(Twist&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Twist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Twist* internal_default_instance() {
    return reinterpret_cast<const Twist*>(
               &_Twist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Twist& a, Twist& b) {
    a.Swap(&b);
  }
  inline void Swap(Twist* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Twist* New() const final {
    return CreateMaybeMessage<Twist>(nullptr);
  }

  Twist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Twist>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Twist& from);
  void MergeFrom(const Twist& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twist* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Twist";
  }
  protected:
  explicit Twist(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .fsm.proto.Vector3 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::fsm::proto::Vector3& linear() const;
  ::fsm::proto::Vector3* release_linear();
  ::fsm::proto::Vector3* mutable_linear();
  void set_allocated_linear(::fsm::proto::Vector3* linear);
  private:
  const ::fsm::proto::Vector3& _internal_linear() const;
  ::fsm::proto::Vector3* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::fsm::proto::Vector3* linear);
  ::fsm::proto::Vector3* unsafe_arena_release_linear();

  // .fsm.proto.Vector3 angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::fsm::proto::Vector3& angular() const;
  ::fsm::proto::Vector3* release_angular();
  ::fsm::proto::Vector3* mutable_angular();
  void set_allocated_angular(::fsm::proto::Vector3* angular);
  private:
  const ::fsm::proto::Vector3& _internal_angular() const;
  ::fsm::proto::Vector3* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::fsm::proto::Vector3* angular);
  ::fsm::proto::Vector3* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:fsm.proto.Twist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Vector3* linear_;
  ::fsm::proto::Vector3* angular_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class LocalizationState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.LocalizationState) */ {
 public:
  inline LocalizationState() : LocalizationState(nullptr) {};
  virtual ~LocalizationState();

  LocalizationState(const LocalizationState& from);
  LocalizationState(LocalizationState&& from) noexcept
    : LocalizationState() {
    *this = ::std::move(from);
  }

  inline LocalizationState& operator=(const LocalizationState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalizationState& operator=(LocalizationState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocalizationState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalizationState* internal_default_instance() {
    return reinterpret_cast<const LocalizationState*>(
               &_LocalizationState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LocalizationState& a, LocalizationState& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalizationState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalizationState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalizationState* New() const final {
    return CreateMaybeMessage<LocalizationState>(nullptr);
  }

  LocalizationState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalizationState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocalizationState& from);
  void MergeFrom(const LocalizationState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalizationState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.LocalizationState";
  }
  protected:
  explicit LocalizationState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 6,
    kStampFieldNumber = 1,
    kPoseFieldNumber = 2,
    kTwistFieldNumber = 3,
    kGeoPointFieldNumber = 4,
    kHeadingFieldNumber = 5,
  };
  // repeated double covariance = 6;
  int covariance_size() const;
  private:
  int _internal_covariance_size() const;
  public:
  void clear_covariance();
  private:
  double _internal_covariance(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_covariance() const;
  void _internal_add_covariance(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_covariance();
  public:
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      covariance() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_covariance();

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.Pose pose = 2;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::fsm::proto::Pose& pose() const;
  ::fsm::proto::Pose* release_pose();
  ::fsm::proto::Pose* mutable_pose();
  void set_allocated_pose(::fsm::proto::Pose* pose);
  private:
  const ::fsm::proto::Pose& _internal_pose() const;
  ::fsm::proto::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::fsm::proto::Pose* pose);
  ::fsm::proto::Pose* unsafe_arena_release_pose();

  // .fsm.proto.Twist twist = 3;
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::fsm::proto::Twist& twist() const;
  ::fsm::proto::Twist* release_twist();
  ::fsm::proto::Twist* mutable_twist();
  void set_allocated_twist(::fsm::proto::Twist* twist);
  private:
  const ::fsm::proto::Twist& _internal_twist() const;
  ::fsm::proto::Twist* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::fsm::proto::Twist* twist);
  ::fsm::proto::Twist* unsafe_arena_release_twist();

  // .fsm.proto.GeoPoint geo_point = 4;
  bool has_geo_point() const;
  private:
  bool _internal_has_geo_point() const;
  public:
  void clear_geo_point();
  const ::fsm::proto::GeoPoint& geo_point() const;
  ::fsm::proto::GeoPoint* release_geo_point();
  ::fsm::proto::GeoPoint* mutable_geo_point();
  void set_allocated_geo_point(::fsm::proto::GeoPoint* geo_point);
  private:
  const ::fsm::proto::GeoPoint& _internal_geo_point() const;
  ::fsm::proto::GeoPoint* _internal_mutable_geo_point();
  public:
  void unsafe_arena_set_allocated_geo_point(
      ::fsm::proto::GeoPoint* geo_point);
  ::fsm::proto::GeoPoint* unsafe_arena_release_geo_point();

  // float heading = 5;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.LocalizationState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > covariance_;
  mutable std::atomic<int> _covariance_cached_byte_size_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::Pose* pose_;
  ::fsm::proto::Twist* twist_;
  ::fsm::proto::GeoPoint* geo_point_;
  float heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DiagnosticStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.DiagnosticStatus) */ {
 public:
  inline DiagnosticStatus() : DiagnosticStatus(nullptr) {};
  virtual ~DiagnosticStatus();

  DiagnosticStatus(const DiagnosticStatus& from);
  DiagnosticStatus(DiagnosticStatus&& from) noexcept
    : DiagnosticStatus() {
    *this = ::std::move(from);
  }

  inline DiagnosticStatus& operator=(const DiagnosticStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiagnosticStatus& operator=(DiagnosticStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DiagnosticStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiagnosticStatus* internal_default_instance() {
    return reinterpret_cast<const DiagnosticStatus*>(
               &_DiagnosticStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DiagnosticStatus& a, DiagnosticStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DiagnosticStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiagnosticStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiagnosticStatus* New() const final {
    return CreateMaybeMessage<DiagnosticStatus>(nullptr);
  }

  DiagnosticStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiagnosticStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DiagnosticStatus& from);
  void MergeFrom(const DiagnosticStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiagnosticStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.DiagnosticStatus";
  }
  protected:
  explicit DiagnosticStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kHardwareIdFieldNumber = 4,
    kLevelFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string hardware_id = 4;
  void clear_hardware_id();
  const std::string& hardware_id() const;
  void set_hardware_id(const std::string& value);
  void set_hardware_id(std::string&& value);
  void set_hardware_id(const char* value);
  void set_hardware_id(const char* value, size_t size);
  std::string* mutable_hardware_id();
  std::string* release_hardware_id();
  void set_allocated_hardware_id(std::string* hardware_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hardware_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hardware_id(
      std::string* hardware_id);
  private:
  const std::string& _internal_hardware_id() const;
  void _internal_set_hardware_id(const std::string& value);
  std::string* _internal_mutable_hardware_id();
  public:

  // .fsm.proto.DiagnosticLevel level = 1;
  void clear_level();
  ::fsm::proto::DiagnosticLevel level() const;
  void set_level(::fsm::proto::DiagnosticLevel value);
  private:
  ::fsm::proto::DiagnosticLevel _internal_level() const;
  void _internal_set_level(::fsm::proto::DiagnosticLevel value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.DiagnosticStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardware_id_;
  int level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SystemStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.SystemStatus) */ {
 public:
  inline SystemStatus() : SystemStatus(nullptr) {};
  virtual ~SystemStatus();

  SystemStatus(const SystemStatus& from);
  SystemStatus(SystemStatus&& from) noexcept
    : SystemStatus() {
    *this = ::std::move(from);
  }

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemStatus& operator=(SystemStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SystemStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemStatus* internal_default_instance() {
    return reinterpret_cast<const SystemStatus*>(
               &_SystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SystemStatus& a, SystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemStatus* New() const final {
    return CreateMaybeMessage<SystemStatus>(nullptr);
  }

  SystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.SystemStatus";
  }
  protected:
  explicit SystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticsFieldNumber = 9,
    kVehicleIdFieldNumber = 2,
    kStampFieldNumber = 1,
    kCpuUsageFieldNumber = 3,
    kMemoryUsageFieldNumber = 4,
    kGpuUsageFieldNumber = 5,
    kDiskUsageFieldNumber = 6,
    kNetworkTxBytesFieldNumber = 7,
    kNetworkRxBytesFieldNumber = 8,
  };
  // repeated .fsm.proto.DiagnosticStatus diagnostics = 9;
  int diagnostics_size() const;
  private:
  int _internal_diagnostics_size() const;
  public:
  void clear_diagnostics();
  ::fsm::proto::DiagnosticStatus* mutable_diagnostics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::DiagnosticStatus >*
      mutable_diagnostics();
  private:
  const ::fsm::proto::DiagnosticStatus& _internal_diagnostics(int index) const;
  ::fsm::proto::DiagnosticStatus* _internal_add_diagnostics();
  public:
  const ::fsm::proto::DiagnosticStatus& diagnostics(int index) const;
  ::fsm::proto::DiagnosticStatus* add_diagnostics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::DiagnosticStatus >&
      diagnostics() const;

  // string vehicle_id = 2;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float cpu_usage = 3;
  void clear_cpu_usage();
  float cpu_usage() const;
  void set_cpu_usage(float value);
  private:
  float _internal_cpu_usage() const;
  void _internal_set_cpu_usage(float value);
  public:

  // float memory_usage = 4;
  void clear_memory_usage();
  float memory_usage() const;
  void set_memory_usage(float value);
  private:
  float _internal_memory_usage() const;
  void _internal_set_memory_usage(float value);
  public:

  // float gpu_usage = 5;
  void clear_gpu_usage();
  float gpu_usage() const;
  void set_gpu_usage(float value);
  private:
  float _internal_gpu_usage() const;
  void _internal_set_gpu_usage(float value);
  public:

  // float disk_usage = 6;
  void clear_disk_usage();
  float disk_usage() const;
  void set_disk_usage(float value);
  private:
  float _internal_disk_usage() const;
  void _internal_set_disk_usage(float value);
  public:

  // float network_tx_bytes = 7;
  void clear_network_tx_bytes();
  float network_tx_bytes() const;
  void set_network_tx_bytes(float value);
  private:
  float _internal_network_tx_bytes() const;
  void _internal_set_network_tx_bytes(float value);
  public:

  // float network_rx_bytes = 8;
  void clear_network_rx_bytes();
  float network_rx_bytes() const;
  void set_network_rx_bytes(float value);
  private:
  float _internal_network_rx_bytes() const;
  void _internal_set_network_rx_bytes(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.SystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::DiagnosticStatus > diagnostics_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::fsm::proto::Timestamp* stamp_;
  float cpu_usage_;
  float memory_usage_;
  float gpu_usage_;
  float disk_usage_;
  float network_tx_bytes_;
  float network_rx_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class LatencyInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.LatencyInfo) */ {
 public:
  inline LatencyInfo() : LatencyInfo(nullptr) {};
  virtual ~LatencyInfo();

  LatencyInfo(const LatencyInfo& from);
  LatencyInfo(LatencyInfo&& from) noexcept
    : LatencyInfo() {
    *this = ::std::move(from);
  }

  inline LatencyInfo& operator=(const LatencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatencyInfo& operator=(LatencyInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LatencyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LatencyInfo* internal_default_instance() {
    return reinterpret_cast<const LatencyInfo*>(
               &_LatencyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LatencyInfo& a, LatencyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LatencyInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatencyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LatencyInfo* New() const final {
    return CreateMaybeMessage<LatencyInfo>(nullptr);
  }

  LatencyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LatencyInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LatencyInfo& from);
  void MergeFrom(const LatencyInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LatencyInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.LatencyInfo";
  }
  protected:
  explicit LatencyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kRttMsFieldNumber = 2,
    kVideoLatencyMsFieldNumber = 3,
    kControlLatencyMsFieldNumber = 4,
    kJitterMsFieldNumber = 5,
    kPacketLossRateFieldNumber = 6,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float rtt_ms = 2;
  void clear_rtt_ms();
  float rtt_ms() const;
  void set_rtt_ms(float value);
  private:
  float _internal_rtt_ms() const;
  void _internal_set_rtt_ms(float value);
  public:

  // float video_latency_ms = 3;
  void clear_video_latency_ms();
  float video_latency_ms() const;
  void set_video_latency_ms(float value);
  private:
  float _internal_video_latency_ms() const;
  void _internal_set_video_latency_ms(float value);
  public:

  // float control_latency_ms = 4;
  void clear_control_latency_ms();
  float control_latency_ms() const;
  void set_control_latency_ms(float value);
  private:
  float _internal_control_latency_ms() const;
  void _internal_set_control_latency_ms(float value);
  public:

  // float jitter_ms = 5;
  void clear_jitter_ms();
  float jitter_ms() const;
  void set_jitter_ms(float value);
  private:
  float _internal_jitter_ms() const;
  void _internal_set_jitter_ms(float value);
  public:

  // float packet_loss_rate = 6;
  void clear_packet_loss_rate();
  float packet_loss_rate() const;
  void set_packet_loss_rate(float value);
  private:
  float _internal_packet_loss_rate() const;
  void _internal_set_packet_loss_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.LatencyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  float rtt_ms_;
  float video_latency_ms_;
  float control_latency_ms_;
  float jitter_ms_;
  float packet_loss_rate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ConnectionStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.ConnectionStatus) */ {
 public:
  inline ConnectionStatus() : ConnectionStatus(nullptr) {};
  virtual ~ConnectionStatus();

  ConnectionStatus(const ConnectionStatus& from);
  ConnectionStatus(ConnectionStatus&& from) noexcept
    : ConnectionStatus() {
    *this = ::std::move(from);
  }

  inline ConnectionStatus& operator=(const ConnectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionStatus& operator=(ConnectionStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionStatus* internal_default_instance() {
    return reinterpret_cast<const ConnectionStatus*>(
               &_ConnectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ConnectionStatus& a, ConnectionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionStatus* New() const final {
    return CreateMaybeMessage<ConnectionStatus>(nullptr);
  }

  ConnectionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionStatus& from);
  void MergeFrom(const ConnectionStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.ConnectionStatus";
  }
  protected:
  explicit ConnectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ConnectionStatus_State State;
  static constexpr State DISCONNECTED =
    ConnectionStatus_State_DISCONNECTED;
  static constexpr State CONNECTING =
    ConnectionStatus_State_CONNECTING;
  static constexpr State CONNECTED =
    ConnectionStatus_State_CONNECTED;
  static constexpr State RECONNECTING =
    ConnectionStatus_State_RECONNECTING;
  static constexpr State FAILED =
    ConnectionStatus_State_FAILED;
  static inline bool State_IsValid(int value) {
    return ConnectionStatus_State_IsValid(value);
  }
  static constexpr State State_MIN =
    ConnectionStatus_State_State_MIN;
  static constexpr State State_MAX =
    ConnectionStatus_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    ConnectionStatus_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return ConnectionStatus_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return ConnectionStatus_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return ConnectionStatus_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdFieldNumber = 2,
    kSignalingServerFieldNumber = 5,
    kTurnServerFieldNumber = 6,
    kStampFieldNumber = 1,
    kLatencyFieldNumber = 4,
    kStateFieldNumber = 3,
    kVideoStreamsActiveFieldNumber = 7,
    kDataChannelOpenFieldNumber = 8,
  };
  // string vehicle_id = 2;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // string signaling_server = 5;
  void clear_signaling_server();
  const std::string& signaling_server() const;
  void set_signaling_server(const std::string& value);
  void set_signaling_server(std::string&& value);
  void set_signaling_server(const char* value);
  void set_signaling_server(const char* value, size_t size);
  std::string* mutable_signaling_server();
  std::string* release_signaling_server();
  void set_allocated_signaling_server(std::string* signaling_server);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signaling_server();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signaling_server(
      std::string* signaling_server);
  private:
  const std::string& _internal_signaling_server() const;
  void _internal_set_signaling_server(const std::string& value);
  std::string* _internal_mutable_signaling_server();
  public:

  // string turn_server = 6;
  void clear_turn_server();
  const std::string& turn_server() const;
  void set_turn_server(const std::string& value);
  void set_turn_server(std::string&& value);
  void set_turn_server(const char* value);
  void set_turn_server(const char* value, size_t size);
  std::string* mutable_turn_server();
  std::string* release_turn_server();
  void set_allocated_turn_server(std::string* turn_server);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_turn_server();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_turn_server(
      std::string* turn_server);
  private:
  const std::string& _internal_turn_server() const;
  void _internal_set_turn_server(const std::string& value);
  std::string* _internal_mutable_turn_server();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.LatencyInfo latency = 4;
  bool has_latency() const;
  private:
  bool _internal_has_latency() const;
  public:
  void clear_latency();
  const ::fsm::proto::LatencyInfo& latency() const;
  ::fsm::proto::LatencyInfo* release_latency();
  ::fsm::proto::LatencyInfo* mutable_latency();
  void set_allocated_latency(::fsm::proto::LatencyInfo* latency);
  private:
  const ::fsm::proto::LatencyInfo& _internal_latency() const;
  ::fsm::proto::LatencyInfo* _internal_mutable_latency();
  public:
  void unsafe_arena_set_allocated_latency(
      ::fsm::proto::LatencyInfo* latency);
  ::fsm::proto::LatencyInfo* unsafe_arena_release_latency();

  // .fsm.proto.ConnectionStatus.State state = 3;
  void clear_state();
  ::fsm::proto::ConnectionStatus_State state() const;
  void set_state(::fsm::proto::ConnectionStatus_State value);
  private:
  ::fsm::proto::ConnectionStatus_State _internal_state() const;
  void _internal_set_state(::fsm::proto::ConnectionStatus_State value);
  public:

  // int32 video_streams_active = 7;
  void clear_video_streams_active();
  ::PROTOBUF_NAMESPACE_ID::int32 video_streams_active() const;
  void set_video_streams_active(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_video_streams_active() const;
  void _internal_set_video_streams_active(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool data_channel_open = 8;
  void clear_data_channel_open();
  bool data_channel_open() const;
  void set_data_channel_open(bool value);
  private:
  bool _internal_data_channel_open() const;
  void _internal_set_data_channel_open(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.ConnectionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signaling_server_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr turn_server_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::LatencyInfo* latency_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::int32 video_streams_active_;
  bool data_channel_open_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SteeringCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.SteeringCommand) */ {
 public:
  inline SteeringCommand() : SteeringCommand(nullptr) {};
  virtual ~SteeringCommand();

  SteeringCommand(const SteeringCommand& from);
  SteeringCommand(SteeringCommand&& from) noexcept
    : SteeringCommand() {
    *this = ::std::move(from);
  }

  inline SteeringCommand& operator=(const SteeringCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteeringCommand& operator=(SteeringCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SteeringCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SteeringCommand* internal_default_instance() {
    return reinterpret_cast<const SteeringCommand*>(
               &_SteeringCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SteeringCommand& a, SteeringCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SteeringCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SteeringCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SteeringCommand* New() const final {
    return CreateMaybeMessage<SteeringCommand>(nullptr);
  }

  SteeringCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SteeringCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SteeringCommand& from);
  void MergeFrom(const SteeringCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteeringCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.SteeringCommand";
  }
  protected:
  explicit SteeringCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kSteeringTireAngleFieldNumber = 2,
    kSteeringTireRotationRateFieldNumber = 3,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float steering_tire_angle = 2;
  void clear_steering_tire_angle();
  float steering_tire_angle() const;
  void set_steering_tire_angle(float value);
  private:
  float _internal_steering_tire_angle() const;
  void _internal_set_steering_tire_angle(float value);
  public:

  // float steering_tire_rotation_rate = 3;
  void clear_steering_tire_rotation_rate();
  float steering_tire_rotation_rate() const;
  void set_steering_tire_rotation_rate(float value);
  private:
  float _internal_steering_tire_rotation_rate() const;
  void _internal_set_steering_tire_rotation_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.SteeringCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  float steering_tire_angle_;
  float steering_tire_rotation_rate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class LongitudinalCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.LongitudinalCommand) */ {
 public:
  inline LongitudinalCommand() : LongitudinalCommand(nullptr) {};
  virtual ~LongitudinalCommand();

  LongitudinalCommand(const LongitudinalCommand& from);
  LongitudinalCommand(LongitudinalCommand&& from) noexcept
    : LongitudinalCommand() {
    *this = ::std::move(from);
  }

  inline LongitudinalCommand& operator=(const LongitudinalCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongitudinalCommand& operator=(LongitudinalCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LongitudinalCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongitudinalCommand* internal_default_instance() {
    return reinterpret_cast<const LongitudinalCommand*>(
               &_LongitudinalCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LongitudinalCommand& a, LongitudinalCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(LongitudinalCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongitudinalCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LongitudinalCommand* New() const final {
    return CreateMaybeMessage<LongitudinalCommand>(nullptr);
  }

  LongitudinalCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LongitudinalCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LongitudinalCommand& from);
  void MergeFrom(const LongitudinalCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongitudinalCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.LongitudinalCommand";
  }
  protected:
  explicit LongitudinalCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kJerkFieldNumber = 4,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float speed = 2;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float acceleration = 3;
  void clear_acceleration();
  float acceleration() const;
  void set_acceleration(float value);
  private:
  float _internal_acceleration() const;
  void _internal_set_acceleration(float value);
  public:

  // float jerk = 4;
  void clear_jerk();
  float jerk() const;
  void set_jerk(float value);
  private:
  float _internal_jerk() const;
  void _internal_set_jerk(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.LongitudinalCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  float speed_;
  float acceleration_;
  float jerk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class GearCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.GearCommand) */ {
 public:
  inline GearCommand() : GearCommand(nullptr) {};
  virtual ~GearCommand();

  GearCommand(const GearCommand& from);
  GearCommand(GearCommand&& from) noexcept
    : GearCommand() {
    *this = ::std::move(from);
  }

  inline GearCommand& operator=(const GearCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GearCommand& operator=(GearCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GearCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GearCommand* internal_default_instance() {
    return reinterpret_cast<const GearCommand*>(
               &_GearCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GearCommand& a, GearCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GearCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GearCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GearCommand* New() const final {
    return CreateMaybeMessage<GearCommand>(nullptr);
  }

  GearCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GearCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GearCommand& from);
  void MergeFrom(const GearCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GearCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.GearCommand";
  }
  protected:
  explicit GearCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kGearFieldNumber = 2,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.GearPosition gear = 2;
  void clear_gear();
  ::fsm::proto::GearPosition gear() const;
  void set_gear(::fsm::proto::GearPosition value);
  private:
  ::fsm::proto::GearPosition _internal_gear() const;
  void _internal_set_gear(::fsm::proto::GearPosition value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.GearCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  int gear_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class TurnSignalCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.TurnSignalCommand) */ {
 public:
  inline TurnSignalCommand() : TurnSignalCommand(nullptr) {};
  virtual ~TurnSignalCommand();

  TurnSignalCommand(const TurnSignalCommand& from);
  TurnSignalCommand(TurnSignalCommand&& from) noexcept
    : TurnSignalCommand() {
    *this = ::std::move(from);
  }

  inline TurnSignalCommand& operator=(const TurnSignalCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnSignalCommand& operator=(TurnSignalCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TurnSignalCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TurnSignalCommand* internal_default_instance() {
    return reinterpret_cast<const TurnSignalCommand*>(
               &_TurnSignalCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TurnSignalCommand& a, TurnSignalCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(TurnSignalCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnSignalCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TurnSignalCommand* New() const final {
    return CreateMaybeMessage<TurnSignalCommand>(nullptr);
  }

  TurnSignalCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TurnSignalCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TurnSignalCommand& from);
  void MergeFrom(const TurnSignalCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnSignalCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.TurnSignalCommand";
  }
  protected:
  explicit TurnSignalCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kSignalFieldNumber = 2,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.TurnSignal signal = 2;
  void clear_signal();
  ::fsm::proto::TurnSignal signal() const;
  void set_signal(::fsm::proto::TurnSignal value);
  private:
  ::fsm::proto::TurnSignal _internal_signal() const;
  void _internal_set_signal(::fsm::proto::TurnSignal value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.TurnSignalCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  int signal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class EmergencyCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.EmergencyCommand) */ {
 public:
  inline EmergencyCommand() : EmergencyCommand(nullptr) {};
  virtual ~EmergencyCommand();

  EmergencyCommand(const EmergencyCommand& from);
  EmergencyCommand(EmergencyCommand&& from) noexcept
    : EmergencyCommand() {
    *this = ::std::move(from);
  }

  inline EmergencyCommand& operator=(const EmergencyCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmergencyCommand& operator=(EmergencyCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmergencyCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmergencyCommand* internal_default_instance() {
    return reinterpret_cast<const EmergencyCommand*>(
               &_EmergencyCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EmergencyCommand& a, EmergencyCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(EmergencyCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmergencyCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmergencyCommand* New() const final {
    return CreateMaybeMessage<EmergencyCommand>(nullptr);
  }

  EmergencyCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmergencyCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmergencyCommand& from);
  void MergeFrom(const EmergencyCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmergencyCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.EmergencyCommand";
  }
  protected:
  explicit EmergencyCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 3,
    kStampFieldNumber = 1,
    kEmergencyFieldNumber = 2,
  };
  // string reason = 3;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reason(
      std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // bool emergency = 2;
  void clear_emergency();
  bool emergency() const;
  void set_emergency(bool value);
  private:
  bool _internal_emergency() const;
  void _internal_set_emergency(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.EmergencyCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::fsm::proto::Timestamp* stamp_;
  bool emergency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ControlCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.ControlCommand) */ {
 public:
  inline ControlCommand() : ControlCommand(nullptr) {};
  virtual ~ControlCommand();

  ControlCommand(const ControlCommand& from);
  ControlCommand(ControlCommand&& from) noexcept
    : ControlCommand() {
    *this = ::std::move(from);
  }

  inline ControlCommand& operator=(const ControlCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlCommand& operator=(ControlCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlCommand* internal_default_instance() {
    return reinterpret_cast<const ControlCommand*>(
               &_ControlCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ControlCommand& a, ControlCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlCommand* New() const final {
    return CreateMaybeMessage<ControlCommand>(nullptr);
  }

  ControlCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlCommand& from);
  void MergeFrom(const ControlCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.ControlCommand";
  }
  protected:
  explicit ControlCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdFieldNumber = 2,
    kOperatorIdFieldNumber = 3,
    kStampFieldNumber = 1,
    kSteeringFieldNumber = 4,
    kLongitudinalFieldNumber = 5,
    kGearFieldNumber = 6,
    kTurnSignalFieldNumber = 7,
    kEmergencyFieldNumber = 8,
    kSequenceNumberFieldNumber = 9,
  };
  // string vehicle_id = 2;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // string operator_id = 3;
  void clear_operator_id();
  const std::string& operator_id() const;
  void set_operator_id(const std::string& value);
  void set_operator_id(std::string&& value);
  void set_operator_id(const char* value);
  void set_operator_id(const char* value, size_t size);
  std::string* mutable_operator_id();
  std::string* release_operator_id();
  void set_allocated_operator_id(std::string* operator_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_operator_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_operator_id(
      std::string* operator_id);
  private:
  const std::string& _internal_operator_id() const;
  void _internal_set_operator_id(const std::string& value);
  std::string* _internal_mutable_operator_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.SteeringCommand steering = 4;
  bool has_steering() const;
  private:
  bool _internal_has_steering() const;
  public:
  void clear_steering();
  const ::fsm::proto::SteeringCommand& steering() const;
  ::fsm::proto::SteeringCommand* release_steering();
  ::fsm::proto::SteeringCommand* mutable_steering();
  void set_allocated_steering(::fsm::proto::SteeringCommand* steering);
  private:
  const ::fsm::proto::SteeringCommand& _internal_steering() const;
  ::fsm::proto::SteeringCommand* _internal_mutable_steering();
  public:
  void unsafe_arena_set_allocated_steering(
      ::fsm::proto::SteeringCommand* steering);
  ::fsm::proto::SteeringCommand* unsafe_arena_release_steering();

  // .fsm.proto.LongitudinalCommand longitudinal = 5;
  bool has_longitudinal() const;
  private:
  bool _internal_has_longitudinal() const;
  public:
  void clear_longitudinal();
  const ::fsm::proto::LongitudinalCommand& longitudinal() const;
  ::fsm::proto::LongitudinalCommand* release_longitudinal();
  ::fsm::proto::LongitudinalCommand* mutable_longitudinal();
  void set_allocated_longitudinal(::fsm::proto::LongitudinalCommand* longitudinal);
  private:
  const ::fsm::proto::LongitudinalCommand& _internal_longitudinal() const;
  ::fsm::proto::LongitudinalCommand* _internal_mutable_longitudinal();
  public:
  void unsafe_arena_set_allocated_longitudinal(
      ::fsm::proto::LongitudinalCommand* longitudinal);
  ::fsm::proto::LongitudinalCommand* unsafe_arena_release_longitudinal();

  // .fsm.proto.GearCommand gear = 6;
  bool has_gear() const;
  private:
  bool _internal_has_gear() const;
  public:
  void clear_gear();
  const ::fsm::proto::GearCommand& gear() const;
  ::fsm::proto::GearCommand* release_gear();
  ::fsm::proto::GearCommand* mutable_gear();
  void set_allocated_gear(::fsm::proto::GearCommand* gear);
  private:
  const ::fsm::proto::GearCommand& _internal_gear() const;
  ::fsm::proto::GearCommand* _internal_mutable_gear();
  public:
  void unsafe_arena_set_allocated_gear(
      ::fsm::proto::GearCommand* gear);
  ::fsm::proto::GearCommand* unsafe_arena_release_gear();

  // .fsm.proto.TurnSignalCommand turn_signal = 7;
  bool has_turn_signal() const;
  private:
  bool _internal_has_turn_signal() const;
  public:
  void clear_turn_signal();
  const ::fsm::proto::TurnSignalCommand& turn_signal() const;
  ::fsm::proto::TurnSignalCommand* release_turn_signal();
  ::fsm::proto::TurnSignalCommand* mutable_turn_signal();
  void set_allocated_turn_signal(::fsm::proto::TurnSignalCommand* turn_signal);
  private:
  const ::fsm::proto::TurnSignalCommand& _internal_turn_signal() const;
  ::fsm::proto::TurnSignalCommand* _internal_mutable_turn_signal();
  public:
  void unsafe_arena_set_allocated_turn_signal(
      ::fsm::proto::TurnSignalCommand* turn_signal);
  ::fsm::proto::TurnSignalCommand* unsafe_arena_release_turn_signal();

  // .fsm.proto.EmergencyCommand emergency = 8;
  bool has_emergency() const;
  private:
  bool _internal_has_emergency() const;
  public:
  void clear_emergency();
  const ::fsm::proto::EmergencyCommand& emergency() const;
  ::fsm::proto::EmergencyCommand* release_emergency();
  ::fsm::proto::EmergencyCommand* mutable_emergency();
  void set_allocated_emergency(::fsm::proto::EmergencyCommand* emergency);
  private:
  const ::fsm::proto::EmergencyCommand& _internal_emergency() const;
  ::fsm::proto::EmergencyCommand* _internal_mutable_emergency();
  public:
  void unsafe_arena_set_allocated_emergency(
      ::fsm::proto::EmergencyCommand* emergency);
  ::fsm::proto::EmergencyCommand* unsafe_arena_release_emergency();

  // uint64 sequence_number = 9;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.ControlCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_id_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::SteeringCommand* steering_;
  ::fsm::proto::LongitudinalCommand* longitudinal_;
  ::fsm::proto::GearCommand* gear_;
  ::fsm::proto::TurnSignalCommand* turn_signal_;
  ::fsm::proto::EmergencyCommand* emergency_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.TelemetryData) */ {
 public:
  inline TelemetryData() : TelemetryData(nullptr) {};
  virtual ~TelemetryData();

  TelemetryData(const TelemetryData& from);
  TelemetryData(TelemetryData&& from) noexcept
    : TelemetryData() {
    *this = ::std::move(from);
  }

  inline TelemetryData& operator=(const TelemetryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryData& operator=(TelemetryData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TelemetryData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TelemetryData* internal_default_instance() {
    return reinterpret_cast<const TelemetryData*>(
               &_TelemetryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TelemetryData& a, TelemetryData& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TelemetryData* New() const final {
    return CreateMaybeMessage<TelemetryData>(nullptr);
  }

  TelemetryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TelemetryData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TelemetryData& from);
  void MergeFrom(const TelemetryData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.TelemetryData";
  }
  protected:
  explicit TelemetryData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdFieldNumber = 2,
    kStampFieldNumber = 1,
    kVehicleStatusFieldNumber = 3,
    kLocalizationFieldNumber = 4,
    kSystemStatusFieldNumber = 5,
    kConnectionFieldNumber = 6,
    kSequenceNumberFieldNumber = 7,
  };
  // string vehicle_id = 2;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.VehicleStatus vehicle_status = 3;
  bool has_vehicle_status() const;
  private:
  bool _internal_has_vehicle_status() const;
  public:
  void clear_vehicle_status();
  const ::fsm::proto::VehicleStatus& vehicle_status() const;
  ::fsm::proto::VehicleStatus* release_vehicle_status();
  ::fsm::proto::VehicleStatus* mutable_vehicle_status();
  void set_allocated_vehicle_status(::fsm::proto::VehicleStatus* vehicle_status);
  private:
  const ::fsm::proto::VehicleStatus& _internal_vehicle_status() const;
  ::fsm::proto::VehicleStatus* _internal_mutable_vehicle_status();
  public:
  void unsafe_arena_set_allocated_vehicle_status(
      ::fsm::proto::VehicleStatus* vehicle_status);
  ::fsm::proto::VehicleStatus* unsafe_arena_release_vehicle_status();

  // .fsm.proto.LocalizationState localization = 4;
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::fsm::proto::LocalizationState& localization() const;
  ::fsm::proto::LocalizationState* release_localization();
  ::fsm::proto::LocalizationState* mutable_localization();
  void set_allocated_localization(::fsm::proto::LocalizationState* localization);
  private:
  const ::fsm::proto::LocalizationState& _internal_localization() const;
  ::fsm::proto::LocalizationState* _internal_mutable_localization();
  public:
  void unsafe_arena_set_allocated_localization(
      ::fsm::proto::LocalizationState* localization);
  ::fsm::proto::LocalizationState* unsafe_arena_release_localization();

  // .fsm.proto.SystemStatus system_status = 5;
  bool has_system_status() const;
  private:
  bool _internal_has_system_status() const;
  public:
  void clear_system_status();
  const ::fsm::proto::SystemStatus& system_status() const;
  ::fsm::proto::SystemStatus* release_system_status();
  ::fsm::proto::SystemStatus* mutable_system_status();
  void set_allocated_system_status(::fsm::proto::SystemStatus* system_status);
  private:
  const ::fsm::proto::SystemStatus& _internal_system_status() const;
  ::fsm::proto::SystemStatus* _internal_mutable_system_status();
  public:
  void unsafe_arena_set_allocated_system_status(
      ::fsm::proto::SystemStatus* system_status);
  ::fsm::proto::SystemStatus* unsafe_arena_release_system_status();

  // .fsm.proto.ConnectionStatus connection = 6;
  bool has_connection() const;
  private:
  bool _internal_has_connection() const;
  public:
  void clear_connection();
  const ::fsm::proto::ConnectionStatus& connection() const;
  ::fsm::proto::ConnectionStatus* release_connection();
  ::fsm::proto::ConnectionStatus* mutable_connection();
  void set_allocated_connection(::fsm::proto::ConnectionStatus* connection);
  private:
  const ::fsm::proto::ConnectionStatus& _internal_connection() const;
  ::fsm::proto::ConnectionStatus* _internal_mutable_connection();
  public:
  void unsafe_arena_set_allocated_connection(
      ::fsm::proto::ConnectionStatus* connection);
  ::fsm::proto::ConnectionStatus* unsafe_arena_release_connection();

  // uint64 sequence_number = 7;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.TelemetryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::VehicleStatus* vehicle_status_;
  ::fsm::proto::LocalizationState* localization_;
  ::fsm::proto::SystemStatus* system_status_;
  ::fsm::proto::ConnectionStatus* connection_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VehicleSchedulingInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.VehicleSchedulingInfo) */ {
 public:
  inline VehicleSchedulingInfo() : VehicleSchedulingInfo(nullptr) {};
  virtual ~VehicleSchedulingInfo();

  VehicleSchedulingInfo(const VehicleSchedulingInfo& from);
  VehicleSchedulingInfo(VehicleSchedulingInfo&& from) noexcept
    : VehicleSchedulingInfo() {
    *this = ::std::move(from);
  }

  inline VehicleSchedulingInfo& operator=(const VehicleSchedulingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleSchedulingInfo& operator=(VehicleSchedulingInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleSchedulingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleSchedulingInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleSchedulingInfo*>(
               &_VehicleSchedulingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VehicleSchedulingInfo& a, VehicleSchedulingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleSchedulingInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleSchedulingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleSchedulingInfo* New() const final {
    return CreateMaybeMessage<VehicleSchedulingInfo>(nullptr);
  }

  VehicleSchedulingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleSchedulingInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleSchedulingInfo& from);
  void MergeFrom(const VehicleSchedulingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleSchedulingInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.VehicleSchedulingInfo";
  }
  protected:
  explicit VehicleSchedulingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdFieldNumber = 1,
    kCurrentTaskFieldNumber = 8,
    kLocationFieldNumber = 5,
    kLastUpdateFieldNumber = 9,
    kTaskStatusFieldNumber = 2,
    kEmergencyLevelFieldNumber = 3,
    kPriorityScoreFieldNumber = 4,
    kLatencyMsFieldNumber = 6,
    kBatteryLevelFieldNumber = 7,
  };
  // string vehicle_id = 1;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // string current_task = 8;
  void clear_current_task();
  const std::string& current_task() const;
  void set_current_task(const std::string& value);
  void set_current_task(std::string&& value);
  void set_current_task(const char* value);
  void set_current_task(const char* value, size_t size);
  std::string* mutable_current_task();
  std::string* release_current_task();
  void set_allocated_current_task(std::string* current_task);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_current_task();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_current_task(
      std::string* current_task);
  private:
  const std::string& _internal_current_task() const;
  void _internal_set_current_task(const std::string& value);
  std::string* _internal_mutable_current_task();
  public:

  // .fsm.proto.GeoPoint location = 5;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::fsm::proto::GeoPoint& location() const;
  ::fsm::proto::GeoPoint* release_location();
  ::fsm::proto::GeoPoint* mutable_location();
  void set_allocated_location(::fsm::proto::GeoPoint* location);
  private:
  const ::fsm::proto::GeoPoint& _internal_location() const;
  ::fsm::proto::GeoPoint* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::fsm::proto::GeoPoint* location);
  ::fsm::proto::GeoPoint* unsafe_arena_release_location();

  // .fsm.proto.Timestamp last_update = 9;
  bool has_last_update() const;
  private:
  bool _internal_has_last_update() const;
  public:
  void clear_last_update();
  const ::fsm::proto::Timestamp& last_update() const;
  ::fsm::proto::Timestamp* release_last_update();
  ::fsm::proto::Timestamp* mutable_last_update();
  void set_allocated_last_update(::fsm::proto::Timestamp* last_update);
  private:
  const ::fsm::proto::Timestamp& _internal_last_update() const;
  ::fsm::proto::Timestamp* _internal_mutable_last_update();
  public:
  void unsafe_arena_set_allocated_last_update(
      ::fsm::proto::Timestamp* last_update);
  ::fsm::proto::Timestamp* unsafe_arena_release_last_update();

  // .fsm.proto.VehicleTaskStatus task_status = 2;
  void clear_task_status();
  ::fsm::proto::VehicleTaskStatus task_status() const;
  void set_task_status(::fsm::proto::VehicleTaskStatus value);
  private:
  ::fsm::proto::VehicleTaskStatus _internal_task_status() const;
  void _internal_set_task_status(::fsm::proto::VehicleTaskStatus value);
  public:

  // .fsm.proto.EmergencyLevel emergency_level = 3;
  void clear_emergency_level();
  ::fsm::proto::EmergencyLevel emergency_level() const;
  void set_emergency_level(::fsm::proto::EmergencyLevel value);
  private:
  ::fsm::proto::EmergencyLevel _internal_emergency_level() const;
  void _internal_set_emergency_level(::fsm::proto::EmergencyLevel value);
  public:

  // float priority_score = 4;
  void clear_priority_score();
  float priority_score() const;
  void set_priority_score(float value);
  private:
  float _internal_priority_score() const;
  void _internal_set_priority_score(float value);
  public:

  // float latency_ms = 6;
  void clear_latency_ms();
  float latency_ms() const;
  void set_latency_ms(float value);
  private:
  float _internal_latency_ms() const;
  void _internal_set_latency_ms(float value);
  public:

  // float battery_level = 7;
  void clear_battery_level();
  float battery_level() const;
  void set_battery_level(float value);
  private:
  float _internal_battery_level() const;
  void _internal_set_battery_level(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.VehicleSchedulingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_task_;
  ::fsm::proto::GeoPoint* location_;
  ::fsm::proto::Timestamp* last_update_;
  int task_status_;
  int emergency_level_;
  float priority_score_;
  float latency_ms_;
  float battery_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SchedulingQueue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.SchedulingQueue) */ {
 public:
  inline SchedulingQueue() : SchedulingQueue(nullptr) {};
  virtual ~SchedulingQueue();

  SchedulingQueue(const SchedulingQueue& from);
  SchedulingQueue(SchedulingQueue&& from) noexcept
    : SchedulingQueue() {
    *this = ::std::move(from);
  }

  inline SchedulingQueue& operator=(const SchedulingQueue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedulingQueue& operator=(SchedulingQueue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SchedulingQueue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchedulingQueue* internal_default_instance() {
    return reinterpret_cast<const SchedulingQueue*>(
               &_SchedulingQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SchedulingQueue& a, SchedulingQueue& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedulingQueue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedulingQueue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchedulingQueue* New() const final {
    return CreateMaybeMessage<SchedulingQueue>(nullptr);
  }

  SchedulingQueue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchedulingQueue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SchedulingQueue& from);
  void MergeFrom(const SchedulingQueue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedulingQueue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.SchedulingQueue";
  }
  protected:
  explicit SchedulingQueue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehiclesFieldNumber = 2,
    kAlgorithmFieldNumber = 3,
    kStampFieldNumber = 1,
    kSchedulingEnabledFieldNumber = 4,
  };
  // repeated .fsm.proto.VehicleSchedulingInfo vehicles = 2;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;
  public:
  void clear_vehicles();
  ::fsm::proto::VehicleSchedulingInfo* mutable_vehicles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::VehicleSchedulingInfo >*
      mutable_vehicles();
  private:
  const ::fsm::proto::VehicleSchedulingInfo& _internal_vehicles(int index) const;
  ::fsm::proto::VehicleSchedulingInfo* _internal_add_vehicles();
  public:
  const ::fsm::proto::VehicleSchedulingInfo& vehicles(int index) const;
  ::fsm::proto::VehicleSchedulingInfo* add_vehicles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::VehicleSchedulingInfo >&
      vehicles() const;

  // string algorithm = 3;
  void clear_algorithm();
  const std::string& algorithm() const;
  void set_algorithm(const std::string& value);
  void set_algorithm(std::string&& value);
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  std::string* mutable_algorithm();
  std::string* release_algorithm();
  void set_allocated_algorithm(std::string* algorithm);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_algorithm();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_algorithm(
      std::string* algorithm);
  private:
  const std::string& _internal_algorithm() const;
  void _internal_set_algorithm(const std::string& value);
  std::string* _internal_mutable_algorithm();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // bool scheduling_enabled = 4;
  void clear_scheduling_enabled();
  bool scheduling_enabled() const;
  void set_scheduling_enabled(bool value);
  private:
  bool _internal_scheduling_enabled() const;
  void _internal_set_scheduling_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.SchedulingQueue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::VehicleSchedulingInfo > vehicles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
  ::fsm::proto::Timestamp* stamp_;
  bool scheduling_enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Alert PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Alert) */ {
 public:
  inline Alert() : Alert(nullptr) {};
  virtual ~Alert();

  Alert(const Alert& from);
  Alert(Alert&& from) noexcept
    : Alert() {
    *this = ::std::move(from);
  }

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alert& operator=(Alert&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Alert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
               &_Alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Alert& a, Alert& b) {
    a.Swap(&b);
  }
  inline void Swap(Alert* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Alert* New() const final {
    return CreateMaybeMessage<Alert>(nullptr);
  }

  Alert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Alert>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alert* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Alert";
  }
  protected:
  explicit Alert(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kVehicleIdFieldNumber = 3,
    kTitleFieldNumber = 6,
    kMessageFieldNumber = 7,
    kAckByFieldNumber = 10,
    kStampFieldNumber = 1,
    kAckTimeFieldNumber = 9,
    kTypeFieldNumber = 4,
    kSeverityFieldNumber = 5,
    kAcknowledgedFieldNumber = 8,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string vehicle_id = 3;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // string title = 6;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_title();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_title(
      std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string message = 7;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string ack_by = 10;
  void clear_ack_by();
  const std::string& ack_by() const;
  void set_ack_by(const std::string& value);
  void set_ack_by(std::string&& value);
  void set_ack_by(const char* value);
  void set_ack_by(const char* value, size_t size);
  std::string* mutable_ack_by();
  std::string* release_ack_by();
  void set_allocated_ack_by(std::string* ack_by);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ack_by();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ack_by(
      std::string* ack_by);
  private:
  const std::string& _internal_ack_by() const;
  void _internal_set_ack_by(const std::string& value);
  std::string* _internal_mutable_ack_by();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.Timestamp ack_time = 9;
  bool has_ack_time() const;
  private:
  bool _internal_has_ack_time() const;
  public:
  void clear_ack_time();
  const ::fsm::proto::Timestamp& ack_time() const;
  ::fsm::proto::Timestamp* release_ack_time();
  ::fsm::proto::Timestamp* mutable_ack_time();
  void set_allocated_ack_time(::fsm::proto::Timestamp* ack_time);
  private:
  const ::fsm::proto::Timestamp& _internal_ack_time() const;
  ::fsm::proto::Timestamp* _internal_mutable_ack_time();
  public:
  void unsafe_arena_set_allocated_ack_time(
      ::fsm::proto::Timestamp* ack_time);
  ::fsm::proto::Timestamp* unsafe_arena_release_ack_time();

  // .fsm.proto.AlertType type = 4;
  void clear_type();
  ::fsm::proto::AlertType type() const;
  void set_type(::fsm::proto::AlertType value);
  private:
  ::fsm::proto::AlertType _internal_type() const;
  void _internal_set_type(::fsm::proto::AlertType value);
  public:

  // .fsm.proto.AlertSeverity severity = 5;
  void clear_severity();
  ::fsm::proto::AlertSeverity severity() const;
  void set_severity(::fsm::proto::AlertSeverity value);
  private:
  ::fsm::proto::AlertSeverity _internal_severity() const;
  void _internal_set_severity(::fsm::proto::AlertSeverity value);
  public:

  // bool acknowledged = 8;
  void clear_acknowledged();
  bool acknowledged() const;
  void set_acknowledged(bool value);
  private:
  bool _internal_acknowledged() const;
  void _internal_set_acknowledged(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.Alert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ack_by_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::Timestamp* ack_time_;
  int type_;
  int severity_;
  bool acknowledged_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class PredictedTrajectoryPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.PredictedTrajectoryPoint) */ {
 public:
  inline PredictedTrajectoryPoint() : PredictedTrajectoryPoint(nullptr) {};
  virtual ~PredictedTrajectoryPoint();

  PredictedTrajectoryPoint(const PredictedTrajectoryPoint& from);
  PredictedTrajectoryPoint(PredictedTrajectoryPoint&& from) noexcept
    : PredictedTrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline PredictedTrajectoryPoint& operator=(const PredictedTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictedTrajectoryPoint& operator=(PredictedTrajectoryPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictedTrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictedTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const PredictedTrajectoryPoint*>(
               &_PredictedTrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PredictedTrajectoryPoint& a, PredictedTrajectoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictedTrajectoryPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictedTrajectoryPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictedTrajectoryPoint* New() const final {
    return CreateMaybeMessage<PredictedTrajectoryPoint>(nullptr);
  }

  PredictedTrajectoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictedTrajectoryPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictedTrajectoryPoint& from);
  void MergeFrom(const PredictedTrajectoryPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictedTrajectoryPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.PredictedTrajectoryPoint";
  }
  protected:
  explicit PredictedTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFromStartFieldNumber = 4,
  };
  // .fsm.proto.Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::fsm::proto::Pose& pose() const;
  ::fsm::proto::Pose* release_pose();
  ::fsm::proto::Pose* mutable_pose();
  void set_allocated_pose(::fsm::proto::Pose* pose);
  private:
  const ::fsm::proto::Pose& _internal_pose() const;
  ::fsm::proto::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::fsm::proto::Pose* pose);
  ::fsm::proto::Pose* unsafe_arena_release_pose();

  // float velocity = 2;
  void clear_velocity();
  float velocity() const;
  void set_velocity(float value);
  private:
  float _internal_velocity() const;
  void _internal_set_velocity(float value);
  public:

  // float acceleration = 3;
  void clear_acceleration();
  float acceleration() const;
  void set_acceleration(float value);
  private:
  float _internal_acceleration() const;
  void _internal_set_acceleration(float value);
  public:

  // float time_from_start = 4;
  void clear_time_from_start();
  float time_from_start() const;
  void set_time_from_start(float value);
  private:
  float _internal_time_from_start() const;
  void _internal_set_time_from_start(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.PredictedTrajectoryPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Pose* pose_;
  float velocity_;
  float acceleration_;
  float time_from_start_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class PredictedTrajectory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.PredictedTrajectory) */ {
 public:
  inline PredictedTrajectory() : PredictedTrajectory(nullptr) {};
  virtual ~PredictedTrajectory();

  PredictedTrajectory(const PredictedTrajectory& from);
  PredictedTrajectory(PredictedTrajectory&& from) noexcept
    : PredictedTrajectory() {
    *this = ::std::move(from);
  }

  inline PredictedTrajectory& operator=(const PredictedTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictedTrajectory& operator=(PredictedTrajectory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictedTrajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictedTrajectory* internal_default_instance() {
    return reinterpret_cast<const PredictedTrajectory*>(
               &_PredictedTrajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PredictedTrajectory& a, PredictedTrajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictedTrajectory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictedTrajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictedTrajectory* New() const final {
    return CreateMaybeMessage<PredictedTrajectory>(nullptr);
  }

  PredictedTrajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictedTrajectory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictedTrajectory& from);
  void MergeFrom(const PredictedTrajectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictedTrajectory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.PredictedTrajectory";
  }
  protected:
  explicit PredictedTrajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 3,
    kVehicleIdFieldNumber = 2,
    kStampFieldNumber = 1,
    kConfidenceFieldNumber = 4,
  };
  // repeated .fsm.proto.PredictedTrajectoryPoint points = 3;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::fsm::proto::PredictedTrajectoryPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::PredictedTrajectoryPoint >*
      mutable_points();
  private:
  const ::fsm::proto::PredictedTrajectoryPoint& _internal_points(int index) const;
  ::fsm::proto::PredictedTrajectoryPoint* _internal_add_points();
  public:
  const ::fsm::proto::PredictedTrajectoryPoint& points(int index) const;
  ::fsm::proto::PredictedTrajectoryPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::PredictedTrajectoryPoint >&
      points() const;

  // string vehicle_id = 2;
  void clear_vehicle_id();
  const std::string& vehicle_id() const;
  void set_vehicle_id(const std::string& value);
  void set_vehicle_id(std::string&& value);
  void set_vehicle_id(const char* value);
  void set_vehicle_id(const char* value, size_t size);
  std::string* mutable_vehicle_id();
  std::string* release_vehicle_id();
  void set_allocated_vehicle_id(std::string* vehicle_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vehicle_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vehicle_id(
      std::string* vehicle_id);
  private:
  const std::string& _internal_vehicle_id() const;
  void _internal_set_vehicle_id(const std::string& value);
  std::string* _internal_mutable_vehicle_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.PredictedTrajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::PredictedTrajectoryPoint > points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicle_id_;
  ::fsm::proto::Timestamp* stamp_;
  float confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class LatencyCompensation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.LatencyCompensation) */ {
 public:
  inline LatencyCompensation() : LatencyCompensation(nullptr) {};
  virtual ~LatencyCompensation();

  LatencyCompensation(const LatencyCompensation& from);
  LatencyCompensation(LatencyCompensation&& from) noexcept
    : LatencyCompensation() {
    *this = ::std::move(from);
  }

  inline LatencyCompensation& operator=(const LatencyCompensation& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatencyCompensation& operator=(LatencyCompensation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LatencyCompensation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LatencyCompensation* internal_default_instance() {
    return reinterpret_cast<const LatencyCompensation*>(
               &_LatencyCompensation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LatencyCompensation& a, LatencyCompensation& b) {
    a.Swap(&b);
  }
  inline void Swap(LatencyCompensation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatencyCompensation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LatencyCompensation* New() const final {
    return CreateMaybeMessage<LatencyCompensation>(nullptr);
  }

  LatencyCompensation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LatencyCompensation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LatencyCompensation& from);
  void MergeFrom(const LatencyCompensation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LatencyCompensation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.LatencyCompensation";
  }
  protected:
  explicit LatencyCompensation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampFieldNumber = 1,
    kPredictedFieldNumber = 3,
    kCompensationTimeFieldNumber = 2,
    kEnabledFieldNumber = 4,
  };
  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.PredictedTrajectory predicted = 3;
  bool has_predicted() const;
  private:
  bool _internal_has_predicted() const;
  public:
  void clear_predicted();
  const ::fsm::proto::PredictedTrajectory& predicted() const;
  ::fsm::proto::PredictedTrajectory* release_predicted();
  ::fsm::proto::PredictedTrajectory* mutable_predicted();
  void set_allocated_predicted(::fsm::proto::PredictedTrajectory* predicted);
  private:
  const ::fsm::proto::PredictedTrajectory& _internal_predicted() const;
  ::fsm::proto::PredictedTrajectory* _internal_mutable_predicted();
  public:
  void unsafe_arena_set_allocated_predicted(
      ::fsm::proto::PredictedTrajectory* predicted);
  ::fsm::proto::PredictedTrajectory* unsafe_arena_release_predicted();

  // float compensation_time = 2;
  void clear_compensation_time();
  float compensation_time() const;
  void set_compensation_time(float value);
  private:
  float _internal_compensation_time() const;
  void _internal_set_compensation_time(float value);
  public:

  // bool enabled = 4;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.LatencyCompensation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::PredictedTrajectory* predicted_;
  float compensation_time_;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VideoFrameMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.VideoFrameMetadata) */ {
 public:
  inline VideoFrameMetadata() : VideoFrameMetadata(nullptr) {};
  virtual ~VideoFrameMetadata();

  VideoFrameMetadata(const VideoFrameMetadata& from);
  VideoFrameMetadata(VideoFrameMetadata&& from) noexcept
    : VideoFrameMetadata() {
    *this = ::std::move(from);
  }

  inline VideoFrameMetadata& operator=(const VideoFrameMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFrameMetadata& operator=(VideoFrameMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoFrameMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoFrameMetadata* internal_default_instance() {
    return reinterpret_cast<const VideoFrameMetadata*>(
               &_VideoFrameMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(VideoFrameMetadata& a, VideoFrameMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFrameMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFrameMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoFrameMetadata* New() const final {
    return CreateMaybeMessage<VideoFrameMetadata>(nullptr);
  }

  VideoFrameMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoFrameMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoFrameMetadata& from);
  void MergeFrom(const VideoFrameMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoFrameMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.VideoFrameMetadata";
  }
  protected:
  explicit VideoFrameMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraIdFieldNumber = 2,
    kEncodingFieldNumber = 5,
    kStampFieldNumber = 1,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kFrameNumberFieldNumber = 6,
    kFpsFieldNumber = 7,
    kBitrateFieldNumber = 8,
  };
  // string camera_id = 2;
  void clear_camera_id();
  const std::string& camera_id() const;
  void set_camera_id(const std::string& value);
  void set_camera_id(std::string&& value);
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  std::string* mutable_camera_id();
  std::string* release_camera_id();
  void set_allocated_camera_id(std::string* camera_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_camera_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_camera_id(
      std::string* camera_id);
  private:
  const std::string& _internal_camera_id() const;
  void _internal_set_camera_id(const std::string& value);
  std::string* _internal_mutable_camera_id();
  public:

  // string encoding = 5;
  void clear_encoding();
  const std::string& encoding() const;
  void set_encoding(const std::string& value);
  void set_encoding(std::string&& value);
  void set_encoding(const char* value);
  void set_encoding(const char* value, size_t size);
  std::string* mutable_encoding();
  std::string* release_encoding();
  void set_allocated_encoding(std::string* encoding);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_encoding();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_encoding(
      std::string* encoding);
  private:
  const std::string& _internal_encoding() const;
  void _internal_set_encoding(const std::string& value);
  std::string* _internal_mutable_encoding();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // uint32 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 frame_number = 6;
  void clear_frame_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_number() const;
  void set_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_number() const;
  void _internal_set_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float fps = 7;
  void clear_fps();
  float fps() const;
  void set_fps(float value);
  private:
  float _internal_fps() const;
  void _internal_set_fps(float value);
  public:

  // uint32 bitrate = 8;
  void clear_bitrate();
  ::PROTOBUF_NAMESPACE_ID::uint32 bitrate() const;
  void set_bitrate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bitrate() const;
  void _internal_set_bitrate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.VideoFrameMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoding_;
  ::fsm::proto::Timestamp* stamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_number_;
  float fps_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bitrate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {};
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const final {
    return CreateMaybeMessage<Heartbeat>(nullptr);
  }

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 2,
    kStampFieldNumber = 1,
    kSequenceFieldNumber = 3,
    kRequestAckFieldNumber = 4,
  };
  // string sender_id = 2;
  void clear_sender_id();
  const std::string& sender_id() const;
  void set_sender_id(const std::string& value);
  void set_sender_id(std::string&& value);
  void set_sender_id(const char* value);
  void set_sender_id(const char* value, size_t size);
  std::string* mutable_sender_id();
  std::string* release_sender_id();
  void set_allocated_sender_id(std::string* sender_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sender_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sender_id(
      std::string* sender_id);
  private:
  const std::string& _internal_sender_id() const;
  void _internal_set_sender_id(const std::string& value);
  std::string* _internal_mutable_sender_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // uint64 sequence = 3;
  void clear_sequence();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence() const;
  void _internal_set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool request_ack = 4;
  void clear_request_ack();
  bool request_ack() const;
  void set_request_ack(bool value);
  private:
  bool _internal_request_ack() const;
  void _internal_set_request_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
  ::fsm::proto::Timestamp* stamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_;
  bool request_ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fsm.proto.HeartbeatAck) */ {
 public:
  inline HeartbeatAck() : HeartbeatAck(nullptr) {};
  virtual ~HeartbeatAck();

  HeartbeatAck(const HeartbeatAck& from);
  HeartbeatAck(HeartbeatAck&& from) noexcept
    : HeartbeatAck() {
    *this = ::std::move(from);
  }

  inline HeartbeatAck& operator=(const HeartbeatAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatAck& operator=(HeartbeatAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HeartbeatAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatAck* internal_default_instance() {
    return reinterpret_cast<const HeartbeatAck*>(
               &_HeartbeatAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(HeartbeatAck& a, HeartbeatAck& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatAck* New() const final {
    return CreateMaybeMessage<HeartbeatAck>(nullptr);
  }

  HeartbeatAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HeartbeatAck& from);
  void MergeFrom(const HeartbeatAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fsm.proto.HeartbeatAck";
  }
  protected:
  explicit HeartbeatAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fsm_5fmessages_2eproto);
    return ::descriptor_table_fsm_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 2,
    kStampFieldNumber = 1,
    kOriginalStampFieldNumber = 4,
    kSequenceFieldNumber = 3,
  };
  // string sender_id = 2;
  void clear_sender_id();
  const std::string& sender_id() const;
  void set_sender_id(const std::string& value);
  void set_sender_id(std::string&& value);
  void set_sender_id(const char* value);
  void set_sender_id(const char* value, size_t size);
  std::string* mutable_sender_id();
  std::string* release_sender_id();
  void set_allocated_sender_id(std::string* sender_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sender_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sender_id(
      std::string* sender_id);
  private:
  const std::string& _internal_sender_id() const;
  void _internal_set_sender_id(const std::string& value);
  std::string* _internal_mutable_sender_id();
  public:

  // .fsm.proto.Timestamp stamp = 1;
  bool has_stamp() const;
  private:
  bool _internal_has_stamp() const;
  public:
  void clear_stamp();
  const ::fsm::proto::Timestamp& stamp() const;
  ::fsm::proto::Timestamp* release_stamp();
  ::fsm::proto::Timestamp* mutable_stamp();
  void set_allocated_stamp(::fsm::proto::Timestamp* stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_stamp();
  public:
  void unsafe_arena_set_allocated_stamp(
      ::fsm::proto::Timestamp* stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_stamp();

  // .fsm.proto.Timestamp original_stamp = 4;
  bool has_original_stamp() const;
  private:
  bool _internal_has_original_stamp() const;
  public:
  void clear_original_stamp();
  const ::fsm::proto::Timestamp& original_stamp() const;
  ::fsm::proto::Timestamp* release_original_stamp();
  ::fsm::proto::Timestamp* mutable_original_stamp();
  void set_allocated_original_stamp(::fsm::proto::Timestamp* original_stamp);
  private:
  const ::fsm::proto::Timestamp& _internal_original_stamp() const;
  ::fsm::proto::Timestamp* _internal_mutable_original_stamp();
  public:
  void unsafe_arena_set_allocated_original_stamp(
      ::fsm::proto::Timestamp* original_stamp);
  ::fsm::proto::Timestamp* unsafe_arena_release_original_stamp();

  // uint64 sequence = 3;
  void clear_sequence();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence() const;
  void _internal_set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:fsm.proto.HeartbeatAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
  ::fsm::proto::Timestamp* stamp_;
  ::fsm::proto::Timestamp* original_stamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fsm_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seconds_ = value;
}
inline void Timestamp::set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Timestamp.seconds)
}

// int32 nanos = 2;
inline void Timestamp::clear_nanos() {
  nanos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Timestamp::_internal_nanos() const {
  return nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Timestamp.nanos)
  return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nanos_ = value;
}
inline void Timestamp::set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Timestamp.nanos)
}

// -------------------------------------------------------------------

// Vector3

// double x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline double Vector3::_internal_x() const {
  return x_;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vector3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Vector3.x)
}

// double y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline double Vector3::_internal_y() const {
  return y_;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vector3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Vector3.y)
}

// double z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline double Vector3::_internal_z() const {
  return z_;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vector3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Vector3.z)
}

// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  x_ = 0;
}
inline double Quaternion::_internal_x() const {
  return x_;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Quaternion.x)
}

// double y = 2;
inline void Quaternion::clear_y() {
  y_ = 0;
}
inline double Quaternion::_internal_y() const {
  return y_;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Quaternion.y)
}

// double z = 3;
inline void Quaternion::clear_z() {
  z_ = 0;
}
inline double Quaternion::_internal_z() const {
  return z_;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Quaternion.z)
}

// double w = 4;
inline void Quaternion::clear_w() {
  w_ = 0;
}
inline double Quaternion::_internal_w() const {
  return w_;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(double value) {
  
  w_ = value;
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Quaternion.w)
}

// -------------------------------------------------------------------

// GeoPoint

// double latitude = 1;
inline void GeoPoint::clear_latitude() {
  latitude_ = 0;
}
inline double GeoPoint::_internal_latitude() const {
  return latitude_;
}
inline double GeoPoint::latitude() const {
  // @@protoc_insertion_point(field_get:fsm.proto.GeoPoint.latitude)
  return _internal_latitude();
}
inline void GeoPoint::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void GeoPoint::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:fsm.proto.GeoPoint.latitude)
}

// double longitude = 2;
inline void GeoPoint::clear_longitude() {
  longitude_ = 0;
}
inline double GeoPoint::_internal_longitude() const {
  return longitude_;
}
inline double GeoPoint::longitude() const {
  // @@protoc_insertion_point(field_get:fsm.proto.GeoPoint.longitude)
  return _internal_longitude();
}
inline void GeoPoint::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void GeoPoint::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:fsm.proto.GeoPoint.longitude)
}

// double altitude = 3;
inline void GeoPoint::clear_altitude() {
  altitude_ = 0;
}
inline double GeoPoint::_internal_altitude() const {
  return altitude_;
}
inline double GeoPoint::altitude() const {
  // @@protoc_insertion_point(field_get:fsm.proto.GeoPoint.altitude)
  return _internal_altitude();
}
inline void GeoPoint::_internal_set_altitude(double value) {
  
  altitude_ = value;
}
inline void GeoPoint::set_altitude(double value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:fsm.proto.GeoPoint.altitude)
}

// -------------------------------------------------------------------

// VelocityStatus

// .fsm.proto.Timestamp stamp = 1;
inline bool VelocityStatus::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool VelocityStatus::has_stamp() const {
  return _internal_has_stamp();
}
inline void VelocityStatus::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& VelocityStatus::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& VelocityStatus::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VelocityStatus.stamp)
  return _internal_stamp();
}
inline void VelocityStatus::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VelocityStatus.stamp)
}
inline ::fsm::proto::Timestamp* VelocityStatus::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* VelocityStatus::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.VelocityStatus.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* VelocityStatus::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* VelocityStatus::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VelocityStatus.stamp)
  return _internal_mutable_stamp();
}
inline void VelocityStatus::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VelocityStatus.stamp)
}

// float longitudinal_velocity = 2;
inline void VelocityStatus::clear_longitudinal_velocity() {
  longitudinal_velocity_ = 0;
}
inline float VelocityStatus::_internal_longitudinal_velocity() const {
  return longitudinal_velocity_;
}
inline float VelocityStatus::longitudinal_velocity() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VelocityStatus.longitudinal_velocity)
  return _internal_longitudinal_velocity();
}
inline void VelocityStatus::_internal_set_longitudinal_velocity(float value) {
  
  longitudinal_velocity_ = value;
}
inline void VelocityStatus::set_longitudinal_velocity(float value) {
  _internal_set_longitudinal_velocity(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VelocityStatus.longitudinal_velocity)
}

// float lateral_velocity = 3;
inline void VelocityStatus::clear_lateral_velocity() {
  lateral_velocity_ = 0;
}
inline float VelocityStatus::_internal_lateral_velocity() const {
  return lateral_velocity_;
}
inline float VelocityStatus::lateral_velocity() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VelocityStatus.lateral_velocity)
  return _internal_lateral_velocity();
}
inline void VelocityStatus::_internal_set_lateral_velocity(float value) {
  
  lateral_velocity_ = value;
}
inline void VelocityStatus::set_lateral_velocity(float value) {
  _internal_set_lateral_velocity(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VelocityStatus.lateral_velocity)
}

// float heading_rate = 4;
inline void VelocityStatus::clear_heading_rate() {
  heading_rate_ = 0;
}
inline float VelocityStatus::_internal_heading_rate() const {
  return heading_rate_;
}
inline float VelocityStatus::heading_rate() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VelocityStatus.heading_rate)
  return _internal_heading_rate();
}
inline void VelocityStatus::_internal_set_heading_rate(float value) {
  
  heading_rate_ = value;
}
inline void VelocityStatus::set_heading_rate(float value) {
  _internal_set_heading_rate(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VelocityStatus.heading_rate)
}

// -------------------------------------------------------------------

// SteeringStatus

// .fsm.proto.Timestamp stamp = 1;
inline bool SteeringStatus::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool SteeringStatus::has_stamp() const {
  return _internal_has_stamp();
}
inline void SteeringStatus::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& SteeringStatus::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& SteeringStatus::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SteeringStatus.stamp)
  return _internal_stamp();
}
inline void SteeringStatus::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.SteeringStatus.stamp)
}
inline ::fsm::proto::Timestamp* SteeringStatus::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* SteeringStatus::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.SteeringStatus.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* SteeringStatus::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* SteeringStatus::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SteeringStatus.stamp)
  return _internal_mutable_stamp();
}
inline void SteeringStatus::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.SteeringStatus.stamp)
}

// float steering_tire_angle = 2;
inline void SteeringStatus::clear_steering_tire_angle() {
  steering_tire_angle_ = 0;
}
inline float SteeringStatus::_internal_steering_tire_angle() const {
  return steering_tire_angle_;
}
inline float SteeringStatus::steering_tire_angle() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SteeringStatus.steering_tire_angle)
  return _internal_steering_tire_angle();
}
inline void SteeringStatus::_internal_set_steering_tire_angle(float value) {
  
  steering_tire_angle_ = value;
}
inline void SteeringStatus::set_steering_tire_angle(float value) {
  _internal_set_steering_tire_angle(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SteeringStatus.steering_tire_angle)
}

// float steering_wheel_angle = 3;
inline void SteeringStatus::clear_steering_wheel_angle() {
  steering_wheel_angle_ = 0;
}
inline float SteeringStatus::_internal_steering_wheel_angle() const {
  return steering_wheel_angle_;
}
inline float SteeringStatus::steering_wheel_angle() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SteeringStatus.steering_wheel_angle)
  return _internal_steering_wheel_angle();
}
inline void SteeringStatus::_internal_set_steering_wheel_angle(float value) {
  
  steering_wheel_angle_ = value;
}
inline void SteeringStatus::set_steering_wheel_angle(float value) {
  _internal_set_steering_wheel_angle(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SteeringStatus.steering_wheel_angle)
}

// -------------------------------------------------------------------

// VehicleStatus

// .fsm.proto.Timestamp stamp = 1;
inline bool VehicleStatus::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool VehicleStatus::has_stamp() const {
  return _internal_has_stamp();
}
inline void VehicleStatus::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& VehicleStatus::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& VehicleStatus::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.stamp)
  return _internal_stamp();
}
inline void VehicleStatus::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleStatus.stamp)
}
inline ::fsm::proto::Timestamp* VehicleStatus::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* VehicleStatus::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleStatus.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* VehicleStatus::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* VehicleStatus::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleStatus.stamp)
  return _internal_mutable_stamp();
}
inline void VehicleStatus::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleStatus.stamp)
}

// string vehicle_id = 2;
inline void VehicleStatus::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VehicleStatus::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.vehicle_id)
  return _internal_vehicle_id();
}
inline void VehicleStatus::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.vehicle_id)
}
inline std::string* VehicleStatus::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleStatus.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& VehicleStatus::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void VehicleStatus::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VehicleStatus::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.VehicleStatus.vehicle_id)
}
inline void VehicleStatus::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.VehicleStatus.vehicle_id)
}
inline void VehicleStatus::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.VehicleStatus.vehicle_id)
}
inline std::string* VehicleStatus::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VehicleStatus::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleStatus.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VehicleStatus::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleStatus.vehicle_id)
}
inline std::string* VehicleStatus::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.VehicleStatus.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VehicleStatus::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleStatus.vehicle_id)
}

// .fsm.proto.VelocityStatus velocity = 3;
inline bool VehicleStatus::_internal_has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline bool VehicleStatus::has_velocity() const {
  return _internal_has_velocity();
}
inline void VehicleStatus::clear_velocity() {
  if (GetArena() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
}
inline const ::fsm::proto::VelocityStatus& VehicleStatus::_internal_velocity() const {
  const ::fsm::proto::VelocityStatus* p = velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::VelocityStatus*>(
      &::fsm::proto::_VelocityStatus_default_instance_);
}
inline const ::fsm::proto::VelocityStatus& VehicleStatus::velocity() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.velocity)
  return _internal_velocity();
}
inline void VehicleStatus::unsafe_arena_set_allocated_velocity(
    ::fsm::proto::VelocityStatus* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleStatus.velocity)
}
inline ::fsm::proto::VelocityStatus* VehicleStatus::release_velocity() {
  auto temp = unsafe_arena_release_velocity();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::VelocityStatus* VehicleStatus::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleStatus.velocity)
  
  ::fsm::proto::VelocityStatus* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::fsm::proto::VelocityStatus* VehicleStatus::_internal_mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::VelocityStatus>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::fsm::proto::VelocityStatus* VehicleStatus::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleStatus.velocity)
  return _internal_mutable_velocity();
}
inline void VehicleStatus::set_allocated_velocity(::fsm::proto::VelocityStatus* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleStatus.velocity)
}

// .fsm.proto.SteeringStatus steering = 4;
inline bool VehicleStatus::_internal_has_steering() const {
  return this != internal_default_instance() && steering_ != nullptr;
}
inline bool VehicleStatus::has_steering() const {
  return _internal_has_steering();
}
inline void VehicleStatus::clear_steering() {
  if (GetArena() == nullptr && steering_ != nullptr) {
    delete steering_;
  }
  steering_ = nullptr;
}
inline const ::fsm::proto::SteeringStatus& VehicleStatus::_internal_steering() const {
  const ::fsm::proto::SteeringStatus* p = steering_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::SteeringStatus*>(
      &::fsm::proto::_SteeringStatus_default_instance_);
}
inline const ::fsm::proto::SteeringStatus& VehicleStatus::steering() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.steering)
  return _internal_steering();
}
inline void VehicleStatus::unsafe_arena_set_allocated_steering(
    ::fsm::proto::SteeringStatus* steering) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(steering_);
  }
  steering_ = steering;
  if (steering) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleStatus.steering)
}
inline ::fsm::proto::SteeringStatus* VehicleStatus::release_steering() {
  auto temp = unsafe_arena_release_steering();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::SteeringStatus* VehicleStatus::unsafe_arena_release_steering() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleStatus.steering)
  
  ::fsm::proto::SteeringStatus* temp = steering_;
  steering_ = nullptr;
  return temp;
}
inline ::fsm::proto::SteeringStatus* VehicleStatus::_internal_mutable_steering() {
  
  if (steering_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::SteeringStatus>(GetArena());
    steering_ = p;
  }
  return steering_;
}
inline ::fsm::proto::SteeringStatus* VehicleStatus::mutable_steering() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleStatus.steering)
  return _internal_mutable_steering();
}
inline void VehicleStatus::set_allocated_steering(::fsm::proto::SteeringStatus* steering) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete steering_;
  }
  if (steering) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(steering);
    if (message_arena != submessage_arena) {
      steering = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering, submessage_arena);
    }
    
  } else {
    
  }
  steering_ = steering;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleStatus.steering)
}

// .fsm.proto.GearPosition gear = 5;
inline void VehicleStatus::clear_gear() {
  gear_ = 0;
}
inline ::fsm::proto::GearPosition VehicleStatus::_internal_gear() const {
  return static_cast< ::fsm::proto::GearPosition >(gear_);
}
inline ::fsm::proto::GearPosition VehicleStatus::gear() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.gear)
  return _internal_gear();
}
inline void VehicleStatus::_internal_set_gear(::fsm::proto::GearPosition value) {
  
  gear_ = value;
}
inline void VehicleStatus::set_gear(::fsm::proto::GearPosition value) {
  _internal_set_gear(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.gear)
}

// .fsm.proto.VehicleMode mode = 6;
inline void VehicleStatus::clear_mode() {
  mode_ = 0;
}
inline ::fsm::proto::VehicleMode VehicleStatus::_internal_mode() const {
  return static_cast< ::fsm::proto::VehicleMode >(mode_);
}
inline ::fsm::proto::VehicleMode VehicleStatus::mode() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.mode)
  return _internal_mode();
}
inline void VehicleStatus::_internal_set_mode(::fsm::proto::VehicleMode value) {
  
  mode_ = value;
}
inline void VehicleStatus::set_mode(::fsm::proto::VehicleMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.mode)
}

// .fsm.proto.TurnSignal turn_signal = 7;
inline void VehicleStatus::clear_turn_signal() {
  turn_signal_ = 0;
}
inline ::fsm::proto::TurnSignal VehicleStatus::_internal_turn_signal() const {
  return static_cast< ::fsm::proto::TurnSignal >(turn_signal_);
}
inline ::fsm::proto::TurnSignal VehicleStatus::turn_signal() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.turn_signal)
  return _internal_turn_signal();
}
inline void VehicleStatus::_internal_set_turn_signal(::fsm::proto::TurnSignal value) {
  
  turn_signal_ = value;
}
inline void VehicleStatus::set_turn_signal(::fsm::proto::TurnSignal value) {
  _internal_set_turn_signal(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.turn_signal)
}

// bool hazard_lights = 8;
inline void VehicleStatus::clear_hazard_lights() {
  hazard_lights_ = false;
}
inline bool VehicleStatus::_internal_hazard_lights() const {
  return hazard_lights_;
}
inline bool VehicleStatus::hazard_lights() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.hazard_lights)
  return _internal_hazard_lights();
}
inline void VehicleStatus::_internal_set_hazard_lights(bool value) {
  
  hazard_lights_ = value;
}
inline void VehicleStatus::set_hazard_lights(bool value) {
  _internal_set_hazard_lights(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.hazard_lights)
}

// bool headlights = 9;
inline void VehicleStatus::clear_headlights() {
  headlights_ = false;
}
inline bool VehicleStatus::_internal_headlights() const {
  return headlights_;
}
inline bool VehicleStatus::headlights() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.headlights)
  return _internal_headlights();
}
inline void VehicleStatus::_internal_set_headlights(bool value) {
  
  headlights_ = value;
}
inline void VehicleStatus::set_headlights(bool value) {
  _internal_set_headlights(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.headlights)
}

// float fuel_level = 10;
inline void VehicleStatus::clear_fuel_level() {
  fuel_level_ = 0;
}
inline float VehicleStatus::_internal_fuel_level() const {
  return fuel_level_;
}
inline float VehicleStatus::fuel_level() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.fuel_level)
  return _internal_fuel_level();
}
inline void VehicleStatus::_internal_set_fuel_level(float value) {
  
  fuel_level_ = value;
}
inline void VehicleStatus::set_fuel_level(float value) {
  _internal_set_fuel_level(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.fuel_level)
}

// float battery_level = 11;
inline void VehicleStatus::clear_battery_level() {
  battery_level_ = 0;
}
inline float VehicleStatus::_internal_battery_level() const {
  return battery_level_;
}
inline float VehicleStatus::battery_level() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleStatus.battery_level)
  return _internal_battery_level();
}
inline void VehicleStatus::_internal_set_battery_level(float value) {
  
  battery_level_ = value;
}
inline void VehicleStatus::set_battery_level(float value) {
  _internal_set_battery_level(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleStatus.battery_level)
}

// -------------------------------------------------------------------

// Pose

// .fsm.proto.Vector3 position = 1;
inline bool Pose::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Pose::has_position() const {
  return _internal_has_position();
}
inline void Pose::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::fsm::proto::Vector3& Pose::_internal_position() const {
  const ::fsm::proto::Vector3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Vector3*>(
      &::fsm::proto::_Vector3_default_instance_);
}
inline const ::fsm::proto::Vector3& Pose::position() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Pose.position)
  return _internal_position();
}
inline void Pose::unsafe_arena_set_allocated_position(
    ::fsm::proto::Vector3* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Pose.position)
}
inline ::fsm::proto::Vector3* Pose::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Vector3* Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:fsm.proto.Pose.position)
  
  ::fsm::proto::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::fsm::proto::Vector3* Pose::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Vector3>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::fsm::proto::Vector3* Pose::mutable_position() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Pose.position)
  return _internal_mutable_position();
}
inline void Pose::set_allocated_position(::fsm::proto::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Pose.position)
}

// .fsm.proto.Quaternion orientation = 2;
inline bool Pose::_internal_has_orientation() const {
  return this != internal_default_instance() && orientation_ != nullptr;
}
inline bool Pose::has_orientation() const {
  return _internal_has_orientation();
}
inline void Pose::clear_orientation() {
  if (GetArena() == nullptr && orientation_ != nullptr) {
    delete orientation_;
  }
  orientation_ = nullptr;
}
inline const ::fsm::proto::Quaternion& Pose::_internal_orientation() const {
  const ::fsm::proto::Quaternion* p = orientation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Quaternion*>(
      &::fsm::proto::_Quaternion_default_instance_);
}
inline const ::fsm::proto::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Pose.orientation)
  return _internal_orientation();
}
inline void Pose::unsafe_arena_set_allocated_orientation(
    ::fsm::proto::Quaternion* orientation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Pose.orientation)
}
inline ::fsm::proto::Quaternion* Pose::release_orientation() {
  auto temp = unsafe_arena_release_orientation();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Quaternion* Pose::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:fsm.proto.Pose.orientation)
  
  ::fsm::proto::Quaternion* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::fsm::proto::Quaternion* Pose::_internal_mutable_orientation() {
  
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Quaternion>(GetArena());
    orientation_ = p;
  }
  return orientation_;
}
inline ::fsm::proto::Quaternion* Pose::mutable_orientation() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Pose.orientation)
  return _internal_mutable_orientation();
}
inline void Pose::set_allocated_orientation(::fsm::proto::Quaternion* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Pose.orientation)
}

// -------------------------------------------------------------------

// Twist

// .fsm.proto.Vector3 linear = 1;
inline bool Twist::_internal_has_linear() const {
  return this != internal_default_instance() && linear_ != nullptr;
}
inline bool Twist::has_linear() const {
  return _internal_has_linear();
}
inline void Twist::clear_linear() {
  if (GetArena() == nullptr && linear_ != nullptr) {
    delete linear_;
  }
  linear_ = nullptr;
}
inline const ::fsm::proto::Vector3& Twist::_internal_linear() const {
  const ::fsm::proto::Vector3* p = linear_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Vector3*>(
      &::fsm::proto::_Vector3_default_instance_);
}
inline const ::fsm::proto::Vector3& Twist::linear() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Twist.linear)
  return _internal_linear();
}
inline void Twist::unsafe_arena_set_allocated_linear(
    ::fsm::proto::Vector3* linear) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_);
  }
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Twist.linear)
}
inline ::fsm::proto::Vector3* Twist::release_linear() {
  auto temp = unsafe_arena_release_linear();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Vector3* Twist::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:fsm.proto.Twist.linear)
  
  ::fsm::proto::Vector3* temp = linear_;
  linear_ = nullptr;
  return temp;
}
inline ::fsm::proto::Vector3* Twist::_internal_mutable_linear() {
  
  if (linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Vector3>(GetArena());
    linear_ = p;
  }
  return linear_;
}
inline ::fsm::proto::Vector3* Twist::mutable_linear() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Twist.linear)
  return _internal_mutable_linear();
}
inline void Twist::set_allocated_linear(::fsm::proto::Vector3* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Twist.linear)
}

// .fsm.proto.Vector3 angular = 2;
inline bool Twist::_internal_has_angular() const {
  return this != internal_default_instance() && angular_ != nullptr;
}
inline bool Twist::has_angular() const {
  return _internal_has_angular();
}
inline void Twist::clear_angular() {
  if (GetArena() == nullptr && angular_ != nullptr) {
    delete angular_;
  }
  angular_ = nullptr;
}
inline const ::fsm::proto::Vector3& Twist::_internal_angular() const {
  const ::fsm::proto::Vector3* p = angular_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Vector3*>(
      &::fsm::proto::_Vector3_default_instance_);
}
inline const ::fsm::proto::Vector3& Twist::angular() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Twist.angular)
  return _internal_angular();
}
inline void Twist::unsafe_arena_set_allocated_angular(
    ::fsm::proto::Vector3* angular) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_);
  }
  angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Twist.angular)
}
inline ::fsm::proto::Vector3* Twist::release_angular() {
  auto temp = unsafe_arena_release_angular();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Vector3* Twist::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:fsm.proto.Twist.angular)
  
  ::fsm::proto::Vector3* temp = angular_;
  angular_ = nullptr;
  return temp;
}
inline ::fsm::proto::Vector3* Twist::_internal_mutable_angular() {
  
  if (angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Vector3>(GetArena());
    angular_ = p;
  }
  return angular_;
}
inline ::fsm::proto::Vector3* Twist::mutable_angular() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Twist.angular)
  return _internal_mutable_angular();
}
inline void Twist::set_allocated_angular(::fsm::proto::Vector3* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    
  } else {
    
  }
  angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Twist.angular)
}

// -------------------------------------------------------------------

// LocalizationState

// .fsm.proto.Timestamp stamp = 1;
inline bool LocalizationState::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool LocalizationState::has_stamp() const {
  return _internal_has_stamp();
}
inline void LocalizationState::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& LocalizationState::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& LocalizationState::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LocalizationState.stamp)
  return _internal_stamp();
}
inline void LocalizationState::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LocalizationState.stamp)
}
inline ::fsm::proto::Timestamp* LocalizationState::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* LocalizationState::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.LocalizationState.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* LocalizationState::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* LocalizationState::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LocalizationState.stamp)
  return _internal_mutable_stamp();
}
inline void LocalizationState::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LocalizationState.stamp)
}

// .fsm.proto.Pose pose = 2;
inline bool LocalizationState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool LocalizationState::has_pose() const {
  return _internal_has_pose();
}
inline void LocalizationState::clear_pose() {
  if (GetArena() == nullptr && pose_ != nullptr) {
    delete pose_;
  }
  pose_ = nullptr;
}
inline const ::fsm::proto::Pose& LocalizationState::_internal_pose() const {
  const ::fsm::proto::Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Pose*>(
      &::fsm::proto::_Pose_default_instance_);
}
inline const ::fsm::proto::Pose& LocalizationState::pose() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LocalizationState.pose)
  return _internal_pose();
}
inline void LocalizationState::unsafe_arena_set_allocated_pose(
    ::fsm::proto::Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LocalizationState.pose)
}
inline ::fsm::proto::Pose* LocalizationState::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Pose* LocalizationState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:fsm.proto.LocalizationState.pose)
  
  ::fsm::proto::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::fsm::proto::Pose* LocalizationState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::fsm::proto::Pose* LocalizationState::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LocalizationState.pose)
  return _internal_mutable_pose();
}
inline void LocalizationState::set_allocated_pose(::fsm::proto::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LocalizationState.pose)
}

// .fsm.proto.Twist twist = 3;
inline bool LocalizationState::_internal_has_twist() const {
  return this != internal_default_instance() && twist_ != nullptr;
}
inline bool LocalizationState::has_twist() const {
  return _internal_has_twist();
}
inline void LocalizationState::clear_twist() {
  if (GetArena() == nullptr && twist_ != nullptr) {
    delete twist_;
  }
  twist_ = nullptr;
}
inline const ::fsm::proto::Twist& LocalizationState::_internal_twist() const {
  const ::fsm::proto::Twist* p = twist_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Twist*>(
      &::fsm::proto::_Twist_default_instance_);
}
inline const ::fsm::proto::Twist& LocalizationState::twist() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LocalizationState.twist)
  return _internal_twist();
}
inline void LocalizationState::unsafe_arena_set_allocated_twist(
    ::fsm::proto::Twist* twist) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(twist_);
  }
  twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LocalizationState.twist)
}
inline ::fsm::proto::Twist* LocalizationState::release_twist() {
  auto temp = unsafe_arena_release_twist();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Twist* LocalizationState::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_release:fsm.proto.LocalizationState.twist)
  
  ::fsm::proto::Twist* temp = twist_;
  twist_ = nullptr;
  return temp;
}
inline ::fsm::proto::Twist* LocalizationState::_internal_mutable_twist() {
  
  if (twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Twist>(GetArena());
    twist_ = p;
  }
  return twist_;
}
inline ::fsm::proto::Twist* LocalizationState::mutable_twist() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LocalizationState.twist)
  return _internal_mutable_twist();
}
inline void LocalizationState::set_allocated_twist(::fsm::proto::Twist* twist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete twist_;
  }
  if (twist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(twist);
    if (message_arena != submessage_arena) {
      twist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LocalizationState.twist)
}

// .fsm.proto.GeoPoint geo_point = 4;
inline bool LocalizationState::_internal_has_geo_point() const {
  return this != internal_default_instance() && geo_point_ != nullptr;
}
inline bool LocalizationState::has_geo_point() const {
  return _internal_has_geo_point();
}
inline void LocalizationState::clear_geo_point() {
  if (GetArena() == nullptr && geo_point_ != nullptr) {
    delete geo_point_;
  }
  geo_point_ = nullptr;
}
inline const ::fsm::proto::GeoPoint& LocalizationState::_internal_geo_point() const {
  const ::fsm::proto::GeoPoint* p = geo_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::GeoPoint*>(
      &::fsm::proto::_GeoPoint_default_instance_);
}
inline const ::fsm::proto::GeoPoint& LocalizationState::geo_point() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LocalizationState.geo_point)
  return _internal_geo_point();
}
inline void LocalizationState::unsafe_arena_set_allocated_geo_point(
    ::fsm::proto::GeoPoint* geo_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geo_point_);
  }
  geo_point_ = geo_point;
  if (geo_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LocalizationState.geo_point)
}
inline ::fsm::proto::GeoPoint* LocalizationState::release_geo_point() {
  auto temp = unsafe_arena_release_geo_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::GeoPoint* LocalizationState::unsafe_arena_release_geo_point() {
  // @@protoc_insertion_point(field_release:fsm.proto.LocalizationState.geo_point)
  
  ::fsm::proto::GeoPoint* temp = geo_point_;
  geo_point_ = nullptr;
  return temp;
}
inline ::fsm::proto::GeoPoint* LocalizationState::_internal_mutable_geo_point() {
  
  if (geo_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::GeoPoint>(GetArena());
    geo_point_ = p;
  }
  return geo_point_;
}
inline ::fsm::proto::GeoPoint* LocalizationState::mutable_geo_point() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LocalizationState.geo_point)
  return _internal_mutable_geo_point();
}
inline void LocalizationState::set_allocated_geo_point(::fsm::proto::GeoPoint* geo_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geo_point_;
  }
  if (geo_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geo_point);
    if (message_arena != submessage_arena) {
      geo_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_point, submessage_arena);
    }
    
  } else {
    
  }
  geo_point_ = geo_point;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LocalizationState.geo_point)
}

// float heading = 5;
inline void LocalizationState::clear_heading() {
  heading_ = 0;
}
inline float LocalizationState::_internal_heading() const {
  return heading_;
}
inline float LocalizationState::heading() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LocalizationState.heading)
  return _internal_heading();
}
inline void LocalizationState::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void LocalizationState::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LocalizationState.heading)
}

// repeated double covariance = 6;
inline int LocalizationState::_internal_covariance_size() const {
  return covariance_.size();
}
inline int LocalizationState::covariance_size() const {
  return _internal_covariance_size();
}
inline void LocalizationState::clear_covariance() {
  covariance_.Clear();
}
inline double LocalizationState::_internal_covariance(int index) const {
  return covariance_.Get(index);
}
inline double LocalizationState::covariance(int index) const {
  // @@protoc_insertion_point(field_get:fsm.proto.LocalizationState.covariance)
  return _internal_covariance(index);
}
inline void LocalizationState::set_covariance(int index, double value) {
  covariance_.Set(index, value);
  // @@protoc_insertion_point(field_set:fsm.proto.LocalizationState.covariance)
}
inline void LocalizationState::_internal_add_covariance(double value) {
  covariance_.Add(value);
}
inline void LocalizationState::add_covariance(double value) {
  _internal_add_covariance(value);
  // @@protoc_insertion_point(field_add:fsm.proto.LocalizationState.covariance)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
LocalizationState::_internal_covariance() const {
  return covariance_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
LocalizationState::covariance() const {
  // @@protoc_insertion_point(field_list:fsm.proto.LocalizationState.covariance)
  return _internal_covariance();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
LocalizationState::_internal_mutable_covariance() {
  return &covariance_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
LocalizationState::mutable_covariance() {
  // @@protoc_insertion_point(field_mutable_list:fsm.proto.LocalizationState.covariance)
  return _internal_mutable_covariance();
}

// -------------------------------------------------------------------

// DiagnosticStatus

// .fsm.proto.DiagnosticLevel level = 1;
inline void DiagnosticStatus::clear_level() {
  level_ = 0;
}
inline ::fsm::proto::DiagnosticLevel DiagnosticStatus::_internal_level() const {
  return static_cast< ::fsm::proto::DiagnosticLevel >(level_);
}
inline ::fsm::proto::DiagnosticLevel DiagnosticStatus::level() const {
  // @@protoc_insertion_point(field_get:fsm.proto.DiagnosticStatus.level)
  return _internal_level();
}
inline void DiagnosticStatus::_internal_set_level(::fsm::proto::DiagnosticLevel value) {
  
  level_ = value;
}
inline void DiagnosticStatus::set_level(::fsm::proto::DiagnosticLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:fsm.proto.DiagnosticStatus.level)
}

// string name = 2;
inline void DiagnosticStatus::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DiagnosticStatus::name() const {
  // @@protoc_insertion_point(field_get:fsm.proto.DiagnosticStatus.name)
  return _internal_name();
}
inline void DiagnosticStatus::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:fsm.proto.DiagnosticStatus.name)
}
inline std::string* DiagnosticStatus::mutable_name() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.DiagnosticStatus.name)
  return _internal_mutable_name();
}
inline const std::string& DiagnosticStatus::_internal_name() const {
  return name_.Get();
}
inline void DiagnosticStatus::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DiagnosticStatus::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.DiagnosticStatus.name)
}
inline void DiagnosticStatus::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.DiagnosticStatus.name)
}
inline void DiagnosticStatus::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.DiagnosticStatus.name)
}
inline std::string* DiagnosticStatus::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DiagnosticStatus::release_name() {
  // @@protoc_insertion_point(field_release:fsm.proto.DiagnosticStatus.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DiagnosticStatus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.DiagnosticStatus.name)
}
inline std::string* DiagnosticStatus::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.DiagnosticStatus.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DiagnosticStatus::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.DiagnosticStatus.name)
}

// string message = 3;
inline void DiagnosticStatus::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DiagnosticStatus::message() const {
  // @@protoc_insertion_point(field_get:fsm.proto.DiagnosticStatus.message)
  return _internal_message();
}
inline void DiagnosticStatus::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:fsm.proto.DiagnosticStatus.message)
}
inline std::string* DiagnosticStatus::mutable_message() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.DiagnosticStatus.message)
  return _internal_mutable_message();
}
inline const std::string& DiagnosticStatus::_internal_message() const {
  return message_.Get();
}
inline void DiagnosticStatus::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DiagnosticStatus::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.DiagnosticStatus.message)
}
inline void DiagnosticStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.DiagnosticStatus.message)
}
inline void DiagnosticStatus::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.DiagnosticStatus.message)
}
inline std::string* DiagnosticStatus::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DiagnosticStatus::release_message() {
  // @@protoc_insertion_point(field_release:fsm.proto.DiagnosticStatus.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DiagnosticStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.DiagnosticStatus.message)
}
inline std::string* DiagnosticStatus::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.DiagnosticStatus.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DiagnosticStatus::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.DiagnosticStatus.message)
}

// string hardware_id = 4;
inline void DiagnosticStatus::clear_hardware_id() {
  hardware_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DiagnosticStatus::hardware_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.DiagnosticStatus.hardware_id)
  return _internal_hardware_id();
}
inline void DiagnosticStatus::set_hardware_id(const std::string& value) {
  _internal_set_hardware_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.DiagnosticStatus.hardware_id)
}
inline std::string* DiagnosticStatus::mutable_hardware_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.DiagnosticStatus.hardware_id)
  return _internal_mutable_hardware_id();
}
inline const std::string& DiagnosticStatus::_internal_hardware_id() const {
  return hardware_id_.Get();
}
inline void DiagnosticStatus::_internal_set_hardware_id(const std::string& value) {
  
  hardware_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DiagnosticStatus::set_hardware_id(std::string&& value) {
  
  hardware_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.DiagnosticStatus.hardware_id)
}
inline void DiagnosticStatus::set_hardware_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hardware_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.DiagnosticStatus.hardware_id)
}
inline void DiagnosticStatus::set_hardware_id(const char* value,
    size_t size) {
  
  hardware_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.DiagnosticStatus.hardware_id)
}
inline std::string* DiagnosticStatus::_internal_mutable_hardware_id() {
  
  return hardware_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DiagnosticStatus::release_hardware_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.DiagnosticStatus.hardware_id)
  return hardware_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DiagnosticStatus::set_allocated_hardware_id(std::string* hardware_id) {
  if (hardware_id != nullptr) {
    
  } else {
    
  }
  hardware_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hardware_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.DiagnosticStatus.hardware_id)
}
inline std::string* DiagnosticStatus::unsafe_arena_release_hardware_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.DiagnosticStatus.hardware_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return hardware_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DiagnosticStatus::unsafe_arena_set_allocated_hardware_id(
    std::string* hardware_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hardware_id != nullptr) {
    
  } else {
    
  }
  hardware_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hardware_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.DiagnosticStatus.hardware_id)
}

// -------------------------------------------------------------------

// SystemStatus

// .fsm.proto.Timestamp stamp = 1;
inline bool SystemStatus::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool SystemStatus::has_stamp() const {
  return _internal_has_stamp();
}
inline void SystemStatus::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& SystemStatus::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& SystemStatus::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.stamp)
  return _internal_stamp();
}
inline void SystemStatus::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.SystemStatus.stamp)
}
inline ::fsm::proto::Timestamp* SystemStatus::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* SystemStatus::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.SystemStatus.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* SystemStatus::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* SystemStatus::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SystemStatus.stamp)
  return _internal_mutable_stamp();
}
inline void SystemStatus::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.SystemStatus.stamp)
}

// string vehicle_id = 2;
inline void SystemStatus::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SystemStatus::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.vehicle_id)
  return _internal_vehicle_id();
}
inline void SystemStatus::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.vehicle_id)
}
inline std::string* SystemStatus::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SystemStatus.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& SystemStatus::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void SystemStatus::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SystemStatus::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.SystemStatus.vehicle_id)
}
inline void SystemStatus::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.SystemStatus.vehicle_id)
}
inline void SystemStatus::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.SystemStatus.vehicle_id)
}
inline std::string* SystemStatus::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SystemStatus::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.SystemStatus.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SystemStatus::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.SystemStatus.vehicle_id)
}
inline std::string* SystemStatus::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.SystemStatus.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SystemStatus::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.SystemStatus.vehicle_id)
}

// float cpu_usage = 3;
inline void SystemStatus::clear_cpu_usage() {
  cpu_usage_ = 0;
}
inline float SystemStatus::_internal_cpu_usage() const {
  return cpu_usage_;
}
inline float SystemStatus::cpu_usage() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.cpu_usage)
  return _internal_cpu_usage();
}
inline void SystemStatus::_internal_set_cpu_usage(float value) {
  
  cpu_usage_ = value;
}
inline void SystemStatus::set_cpu_usage(float value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.cpu_usage)
}

// float memory_usage = 4;
inline void SystemStatus::clear_memory_usage() {
  memory_usage_ = 0;
}
inline float SystemStatus::_internal_memory_usage() const {
  return memory_usage_;
}
inline float SystemStatus::memory_usage() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.memory_usage)
  return _internal_memory_usage();
}
inline void SystemStatus::_internal_set_memory_usage(float value) {
  
  memory_usage_ = value;
}
inline void SystemStatus::set_memory_usage(float value) {
  _internal_set_memory_usage(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.memory_usage)
}

// float gpu_usage = 5;
inline void SystemStatus::clear_gpu_usage() {
  gpu_usage_ = 0;
}
inline float SystemStatus::_internal_gpu_usage() const {
  return gpu_usage_;
}
inline float SystemStatus::gpu_usage() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.gpu_usage)
  return _internal_gpu_usage();
}
inline void SystemStatus::_internal_set_gpu_usage(float value) {
  
  gpu_usage_ = value;
}
inline void SystemStatus::set_gpu_usage(float value) {
  _internal_set_gpu_usage(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.gpu_usage)
}

// float disk_usage = 6;
inline void SystemStatus::clear_disk_usage() {
  disk_usage_ = 0;
}
inline float SystemStatus::_internal_disk_usage() const {
  return disk_usage_;
}
inline float SystemStatus::disk_usage() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.disk_usage)
  return _internal_disk_usage();
}
inline void SystemStatus::_internal_set_disk_usage(float value) {
  
  disk_usage_ = value;
}
inline void SystemStatus::set_disk_usage(float value) {
  _internal_set_disk_usage(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.disk_usage)
}

// float network_tx_bytes = 7;
inline void SystemStatus::clear_network_tx_bytes() {
  network_tx_bytes_ = 0;
}
inline float SystemStatus::_internal_network_tx_bytes() const {
  return network_tx_bytes_;
}
inline float SystemStatus::network_tx_bytes() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.network_tx_bytes)
  return _internal_network_tx_bytes();
}
inline void SystemStatus::_internal_set_network_tx_bytes(float value) {
  
  network_tx_bytes_ = value;
}
inline void SystemStatus::set_network_tx_bytes(float value) {
  _internal_set_network_tx_bytes(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.network_tx_bytes)
}

// float network_rx_bytes = 8;
inline void SystemStatus::clear_network_rx_bytes() {
  network_rx_bytes_ = 0;
}
inline float SystemStatus::_internal_network_rx_bytes() const {
  return network_rx_bytes_;
}
inline float SystemStatus::network_rx_bytes() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.network_rx_bytes)
  return _internal_network_rx_bytes();
}
inline void SystemStatus::_internal_set_network_rx_bytes(float value) {
  
  network_rx_bytes_ = value;
}
inline void SystemStatus::set_network_rx_bytes(float value) {
  _internal_set_network_rx_bytes(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SystemStatus.network_rx_bytes)
}

// repeated .fsm.proto.DiagnosticStatus diagnostics = 9;
inline int SystemStatus::_internal_diagnostics_size() const {
  return diagnostics_.size();
}
inline int SystemStatus::diagnostics_size() const {
  return _internal_diagnostics_size();
}
inline void SystemStatus::clear_diagnostics() {
  diagnostics_.Clear();
}
inline ::fsm::proto::DiagnosticStatus* SystemStatus::mutable_diagnostics(int index) {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SystemStatus.diagnostics)
  return diagnostics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::DiagnosticStatus >*
SystemStatus::mutable_diagnostics() {
  // @@protoc_insertion_point(field_mutable_list:fsm.proto.SystemStatus.diagnostics)
  return &diagnostics_;
}
inline const ::fsm::proto::DiagnosticStatus& SystemStatus::_internal_diagnostics(int index) const {
  return diagnostics_.Get(index);
}
inline const ::fsm::proto::DiagnosticStatus& SystemStatus::diagnostics(int index) const {
  // @@protoc_insertion_point(field_get:fsm.proto.SystemStatus.diagnostics)
  return _internal_diagnostics(index);
}
inline ::fsm::proto::DiagnosticStatus* SystemStatus::_internal_add_diagnostics() {
  return diagnostics_.Add();
}
inline ::fsm::proto::DiagnosticStatus* SystemStatus::add_diagnostics() {
  // @@protoc_insertion_point(field_add:fsm.proto.SystemStatus.diagnostics)
  return _internal_add_diagnostics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::DiagnosticStatus >&
SystemStatus::diagnostics() const {
  // @@protoc_insertion_point(field_list:fsm.proto.SystemStatus.diagnostics)
  return diagnostics_;
}

// -------------------------------------------------------------------

// LatencyInfo

// .fsm.proto.Timestamp stamp = 1;
inline bool LatencyInfo::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool LatencyInfo::has_stamp() const {
  return _internal_has_stamp();
}
inline void LatencyInfo::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& LatencyInfo::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& LatencyInfo::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyInfo.stamp)
  return _internal_stamp();
}
inline void LatencyInfo::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LatencyInfo.stamp)
}
inline ::fsm::proto::Timestamp* LatencyInfo::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* LatencyInfo::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.LatencyInfo.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* LatencyInfo::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* LatencyInfo::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LatencyInfo.stamp)
  return _internal_mutable_stamp();
}
inline void LatencyInfo::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LatencyInfo.stamp)
}

// float rtt_ms = 2;
inline void LatencyInfo::clear_rtt_ms() {
  rtt_ms_ = 0;
}
inline float LatencyInfo::_internal_rtt_ms() const {
  return rtt_ms_;
}
inline float LatencyInfo::rtt_ms() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyInfo.rtt_ms)
  return _internal_rtt_ms();
}
inline void LatencyInfo::_internal_set_rtt_ms(float value) {
  
  rtt_ms_ = value;
}
inline void LatencyInfo::set_rtt_ms(float value) {
  _internal_set_rtt_ms(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyInfo.rtt_ms)
}

// float video_latency_ms = 3;
inline void LatencyInfo::clear_video_latency_ms() {
  video_latency_ms_ = 0;
}
inline float LatencyInfo::_internal_video_latency_ms() const {
  return video_latency_ms_;
}
inline float LatencyInfo::video_latency_ms() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyInfo.video_latency_ms)
  return _internal_video_latency_ms();
}
inline void LatencyInfo::_internal_set_video_latency_ms(float value) {
  
  video_latency_ms_ = value;
}
inline void LatencyInfo::set_video_latency_ms(float value) {
  _internal_set_video_latency_ms(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyInfo.video_latency_ms)
}

// float control_latency_ms = 4;
inline void LatencyInfo::clear_control_latency_ms() {
  control_latency_ms_ = 0;
}
inline float LatencyInfo::_internal_control_latency_ms() const {
  return control_latency_ms_;
}
inline float LatencyInfo::control_latency_ms() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyInfo.control_latency_ms)
  return _internal_control_latency_ms();
}
inline void LatencyInfo::_internal_set_control_latency_ms(float value) {
  
  control_latency_ms_ = value;
}
inline void LatencyInfo::set_control_latency_ms(float value) {
  _internal_set_control_latency_ms(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyInfo.control_latency_ms)
}

// float jitter_ms = 5;
inline void LatencyInfo::clear_jitter_ms() {
  jitter_ms_ = 0;
}
inline float LatencyInfo::_internal_jitter_ms() const {
  return jitter_ms_;
}
inline float LatencyInfo::jitter_ms() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyInfo.jitter_ms)
  return _internal_jitter_ms();
}
inline void LatencyInfo::_internal_set_jitter_ms(float value) {
  
  jitter_ms_ = value;
}
inline void LatencyInfo::set_jitter_ms(float value) {
  _internal_set_jitter_ms(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyInfo.jitter_ms)
}

// float packet_loss_rate = 6;
inline void LatencyInfo::clear_packet_loss_rate() {
  packet_loss_rate_ = 0;
}
inline float LatencyInfo::_internal_packet_loss_rate() const {
  return packet_loss_rate_;
}
inline float LatencyInfo::packet_loss_rate() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyInfo.packet_loss_rate)
  return _internal_packet_loss_rate();
}
inline void LatencyInfo::_internal_set_packet_loss_rate(float value) {
  
  packet_loss_rate_ = value;
}
inline void LatencyInfo::set_packet_loss_rate(float value) {
  _internal_set_packet_loss_rate(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyInfo.packet_loss_rate)
}

// -------------------------------------------------------------------

// ConnectionStatus

// .fsm.proto.Timestamp stamp = 1;
inline bool ConnectionStatus::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool ConnectionStatus::has_stamp() const {
  return _internal_has_stamp();
}
inline void ConnectionStatus::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& ConnectionStatus::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& ConnectionStatus::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.stamp)
  return _internal_stamp();
}
inline void ConnectionStatus::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ConnectionStatus.stamp)
}
inline ::fsm::proto::Timestamp* ConnectionStatus::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* ConnectionStatus::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.ConnectionStatus.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* ConnectionStatus::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* ConnectionStatus::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ConnectionStatus.stamp)
  return _internal_mutable_stamp();
}
inline void ConnectionStatus::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ConnectionStatus.stamp)
}

// string vehicle_id = 2;
inline void ConnectionStatus::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionStatus::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.vehicle_id)
  return _internal_vehicle_id();
}
inline void ConnectionStatus::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ConnectionStatus.vehicle_id)
}
inline std::string* ConnectionStatus::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ConnectionStatus.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& ConnectionStatus::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void ConnectionStatus::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionStatus::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.ConnectionStatus.vehicle_id)
}
inline void ConnectionStatus::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.ConnectionStatus.vehicle_id)
}
inline void ConnectionStatus::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.ConnectionStatus.vehicle_id)
}
inline std::string* ConnectionStatus::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionStatus::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.ConnectionStatus.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionStatus::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ConnectionStatus.vehicle_id)
}
inline std::string* ConnectionStatus::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.ConnectionStatus.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionStatus::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ConnectionStatus.vehicle_id)
}

// .fsm.proto.ConnectionStatus.State state = 3;
inline void ConnectionStatus::clear_state() {
  state_ = 0;
}
inline ::fsm::proto::ConnectionStatus_State ConnectionStatus::_internal_state() const {
  return static_cast< ::fsm::proto::ConnectionStatus_State >(state_);
}
inline ::fsm::proto::ConnectionStatus_State ConnectionStatus::state() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.state)
  return _internal_state();
}
inline void ConnectionStatus::_internal_set_state(::fsm::proto::ConnectionStatus_State value) {
  
  state_ = value;
}
inline void ConnectionStatus::set_state(::fsm::proto::ConnectionStatus_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ConnectionStatus.state)
}

// .fsm.proto.LatencyInfo latency = 4;
inline bool ConnectionStatus::_internal_has_latency() const {
  return this != internal_default_instance() && latency_ != nullptr;
}
inline bool ConnectionStatus::has_latency() const {
  return _internal_has_latency();
}
inline void ConnectionStatus::clear_latency() {
  if (GetArena() == nullptr && latency_ != nullptr) {
    delete latency_;
  }
  latency_ = nullptr;
}
inline const ::fsm::proto::LatencyInfo& ConnectionStatus::_internal_latency() const {
  const ::fsm::proto::LatencyInfo* p = latency_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::LatencyInfo*>(
      &::fsm::proto::_LatencyInfo_default_instance_);
}
inline const ::fsm::proto::LatencyInfo& ConnectionStatus::latency() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.latency)
  return _internal_latency();
}
inline void ConnectionStatus::unsafe_arena_set_allocated_latency(
    ::fsm::proto::LatencyInfo* latency) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency_);
  }
  latency_ = latency;
  if (latency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ConnectionStatus.latency)
}
inline ::fsm::proto::LatencyInfo* ConnectionStatus::release_latency() {
  auto temp = unsafe_arena_release_latency();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::LatencyInfo* ConnectionStatus::unsafe_arena_release_latency() {
  // @@protoc_insertion_point(field_release:fsm.proto.ConnectionStatus.latency)
  
  ::fsm::proto::LatencyInfo* temp = latency_;
  latency_ = nullptr;
  return temp;
}
inline ::fsm::proto::LatencyInfo* ConnectionStatus::_internal_mutable_latency() {
  
  if (latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::LatencyInfo>(GetArena());
    latency_ = p;
  }
  return latency_;
}
inline ::fsm::proto::LatencyInfo* ConnectionStatus::mutable_latency() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ConnectionStatus.latency)
  return _internal_mutable_latency();
}
inline void ConnectionStatus::set_allocated_latency(::fsm::proto::LatencyInfo* latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete latency_;
  }
  if (latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(latency);
    if (message_arena != submessage_arena) {
      latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latency, submessage_arena);
    }
    
  } else {
    
  }
  latency_ = latency;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ConnectionStatus.latency)
}

// string signaling_server = 5;
inline void ConnectionStatus::clear_signaling_server() {
  signaling_server_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionStatus::signaling_server() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.signaling_server)
  return _internal_signaling_server();
}
inline void ConnectionStatus::set_signaling_server(const std::string& value) {
  _internal_set_signaling_server(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ConnectionStatus.signaling_server)
}
inline std::string* ConnectionStatus::mutable_signaling_server() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ConnectionStatus.signaling_server)
  return _internal_mutable_signaling_server();
}
inline const std::string& ConnectionStatus::_internal_signaling_server() const {
  return signaling_server_.Get();
}
inline void ConnectionStatus::_internal_set_signaling_server(const std::string& value) {
  
  signaling_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionStatus::set_signaling_server(std::string&& value) {
  
  signaling_server_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.ConnectionStatus.signaling_server)
}
inline void ConnectionStatus::set_signaling_server(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signaling_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.ConnectionStatus.signaling_server)
}
inline void ConnectionStatus::set_signaling_server(const char* value,
    size_t size) {
  
  signaling_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.ConnectionStatus.signaling_server)
}
inline std::string* ConnectionStatus::_internal_mutable_signaling_server() {
  
  return signaling_server_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionStatus::release_signaling_server() {
  // @@protoc_insertion_point(field_release:fsm.proto.ConnectionStatus.signaling_server)
  return signaling_server_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionStatus::set_allocated_signaling_server(std::string* signaling_server) {
  if (signaling_server != nullptr) {
    
  } else {
    
  }
  signaling_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signaling_server,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ConnectionStatus.signaling_server)
}
inline std::string* ConnectionStatus::unsafe_arena_release_signaling_server() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.ConnectionStatus.signaling_server)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return signaling_server_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionStatus::unsafe_arena_set_allocated_signaling_server(
    std::string* signaling_server) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signaling_server != nullptr) {
    
  } else {
    
  }
  signaling_server_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signaling_server, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ConnectionStatus.signaling_server)
}

// string turn_server = 6;
inline void ConnectionStatus::clear_turn_server() {
  turn_server_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionStatus::turn_server() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.turn_server)
  return _internal_turn_server();
}
inline void ConnectionStatus::set_turn_server(const std::string& value) {
  _internal_set_turn_server(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ConnectionStatus.turn_server)
}
inline std::string* ConnectionStatus::mutable_turn_server() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ConnectionStatus.turn_server)
  return _internal_mutable_turn_server();
}
inline const std::string& ConnectionStatus::_internal_turn_server() const {
  return turn_server_.Get();
}
inline void ConnectionStatus::_internal_set_turn_server(const std::string& value) {
  
  turn_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionStatus::set_turn_server(std::string&& value) {
  
  turn_server_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.ConnectionStatus.turn_server)
}
inline void ConnectionStatus::set_turn_server(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  turn_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.ConnectionStatus.turn_server)
}
inline void ConnectionStatus::set_turn_server(const char* value,
    size_t size) {
  
  turn_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.ConnectionStatus.turn_server)
}
inline std::string* ConnectionStatus::_internal_mutable_turn_server() {
  
  return turn_server_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionStatus::release_turn_server() {
  // @@protoc_insertion_point(field_release:fsm.proto.ConnectionStatus.turn_server)
  return turn_server_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionStatus::set_allocated_turn_server(std::string* turn_server) {
  if (turn_server != nullptr) {
    
  } else {
    
  }
  turn_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), turn_server,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ConnectionStatus.turn_server)
}
inline std::string* ConnectionStatus::unsafe_arena_release_turn_server() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.ConnectionStatus.turn_server)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return turn_server_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionStatus::unsafe_arena_set_allocated_turn_server(
    std::string* turn_server) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (turn_server != nullptr) {
    
  } else {
    
  }
  turn_server_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      turn_server, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ConnectionStatus.turn_server)
}

// int32 video_streams_active = 7;
inline void ConnectionStatus::clear_video_streams_active() {
  video_streams_active_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectionStatus::_internal_video_streams_active() const {
  return video_streams_active_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectionStatus::video_streams_active() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.video_streams_active)
  return _internal_video_streams_active();
}
inline void ConnectionStatus::_internal_set_video_streams_active(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  video_streams_active_ = value;
}
inline void ConnectionStatus::set_video_streams_active(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_video_streams_active(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ConnectionStatus.video_streams_active)
}

// bool data_channel_open = 8;
inline void ConnectionStatus::clear_data_channel_open() {
  data_channel_open_ = false;
}
inline bool ConnectionStatus::_internal_data_channel_open() const {
  return data_channel_open_;
}
inline bool ConnectionStatus::data_channel_open() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ConnectionStatus.data_channel_open)
  return _internal_data_channel_open();
}
inline void ConnectionStatus::_internal_set_data_channel_open(bool value) {
  
  data_channel_open_ = value;
}
inline void ConnectionStatus::set_data_channel_open(bool value) {
  _internal_set_data_channel_open(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ConnectionStatus.data_channel_open)
}

// -------------------------------------------------------------------

// SteeringCommand

// .fsm.proto.Timestamp stamp = 1;
inline bool SteeringCommand::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool SteeringCommand::has_stamp() const {
  return _internal_has_stamp();
}
inline void SteeringCommand::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& SteeringCommand::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& SteeringCommand::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SteeringCommand.stamp)
  return _internal_stamp();
}
inline void SteeringCommand::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.SteeringCommand.stamp)
}
inline ::fsm::proto::Timestamp* SteeringCommand::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* SteeringCommand::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.SteeringCommand.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* SteeringCommand::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* SteeringCommand::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SteeringCommand.stamp)
  return _internal_mutable_stamp();
}
inline void SteeringCommand::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.SteeringCommand.stamp)
}

// float steering_tire_angle = 2;
inline void SteeringCommand::clear_steering_tire_angle() {
  steering_tire_angle_ = 0;
}
inline float SteeringCommand::_internal_steering_tire_angle() const {
  return steering_tire_angle_;
}
inline float SteeringCommand::steering_tire_angle() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SteeringCommand.steering_tire_angle)
  return _internal_steering_tire_angle();
}
inline void SteeringCommand::_internal_set_steering_tire_angle(float value) {
  
  steering_tire_angle_ = value;
}
inline void SteeringCommand::set_steering_tire_angle(float value) {
  _internal_set_steering_tire_angle(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SteeringCommand.steering_tire_angle)
}

// float steering_tire_rotation_rate = 3;
inline void SteeringCommand::clear_steering_tire_rotation_rate() {
  steering_tire_rotation_rate_ = 0;
}
inline float SteeringCommand::_internal_steering_tire_rotation_rate() const {
  return steering_tire_rotation_rate_;
}
inline float SteeringCommand::steering_tire_rotation_rate() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SteeringCommand.steering_tire_rotation_rate)
  return _internal_steering_tire_rotation_rate();
}
inline void SteeringCommand::_internal_set_steering_tire_rotation_rate(float value) {
  
  steering_tire_rotation_rate_ = value;
}
inline void SteeringCommand::set_steering_tire_rotation_rate(float value) {
  _internal_set_steering_tire_rotation_rate(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SteeringCommand.steering_tire_rotation_rate)
}

// -------------------------------------------------------------------

// LongitudinalCommand

// .fsm.proto.Timestamp stamp = 1;
inline bool LongitudinalCommand::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool LongitudinalCommand::has_stamp() const {
  return _internal_has_stamp();
}
inline void LongitudinalCommand::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& LongitudinalCommand::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& LongitudinalCommand::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LongitudinalCommand.stamp)
  return _internal_stamp();
}
inline void LongitudinalCommand::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LongitudinalCommand.stamp)
}
inline ::fsm::proto::Timestamp* LongitudinalCommand::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* LongitudinalCommand::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.LongitudinalCommand.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* LongitudinalCommand::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* LongitudinalCommand::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LongitudinalCommand.stamp)
  return _internal_mutable_stamp();
}
inline void LongitudinalCommand::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LongitudinalCommand.stamp)
}

// float speed = 2;
inline void LongitudinalCommand::clear_speed() {
  speed_ = 0;
}
inline float LongitudinalCommand::_internal_speed() const {
  return speed_;
}
inline float LongitudinalCommand::speed() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LongitudinalCommand.speed)
  return _internal_speed();
}
inline void LongitudinalCommand::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void LongitudinalCommand::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LongitudinalCommand.speed)
}

// float acceleration = 3;
inline void LongitudinalCommand::clear_acceleration() {
  acceleration_ = 0;
}
inline float LongitudinalCommand::_internal_acceleration() const {
  return acceleration_;
}
inline float LongitudinalCommand::acceleration() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LongitudinalCommand.acceleration)
  return _internal_acceleration();
}
inline void LongitudinalCommand::_internal_set_acceleration(float value) {
  
  acceleration_ = value;
}
inline void LongitudinalCommand::set_acceleration(float value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LongitudinalCommand.acceleration)
}

// float jerk = 4;
inline void LongitudinalCommand::clear_jerk() {
  jerk_ = 0;
}
inline float LongitudinalCommand::_internal_jerk() const {
  return jerk_;
}
inline float LongitudinalCommand::jerk() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LongitudinalCommand.jerk)
  return _internal_jerk();
}
inline void LongitudinalCommand::_internal_set_jerk(float value) {
  
  jerk_ = value;
}
inline void LongitudinalCommand::set_jerk(float value) {
  _internal_set_jerk(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LongitudinalCommand.jerk)
}

// -------------------------------------------------------------------

// GearCommand

// .fsm.proto.Timestamp stamp = 1;
inline bool GearCommand::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool GearCommand::has_stamp() const {
  return _internal_has_stamp();
}
inline void GearCommand::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& GearCommand::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& GearCommand::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.GearCommand.stamp)
  return _internal_stamp();
}
inline void GearCommand::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.GearCommand.stamp)
}
inline ::fsm::proto::Timestamp* GearCommand::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* GearCommand::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.GearCommand.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* GearCommand::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* GearCommand::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.GearCommand.stamp)
  return _internal_mutable_stamp();
}
inline void GearCommand::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.GearCommand.stamp)
}

// .fsm.proto.GearPosition gear = 2;
inline void GearCommand::clear_gear() {
  gear_ = 0;
}
inline ::fsm::proto::GearPosition GearCommand::_internal_gear() const {
  return static_cast< ::fsm::proto::GearPosition >(gear_);
}
inline ::fsm::proto::GearPosition GearCommand::gear() const {
  // @@protoc_insertion_point(field_get:fsm.proto.GearCommand.gear)
  return _internal_gear();
}
inline void GearCommand::_internal_set_gear(::fsm::proto::GearPosition value) {
  
  gear_ = value;
}
inline void GearCommand::set_gear(::fsm::proto::GearPosition value) {
  _internal_set_gear(value);
  // @@protoc_insertion_point(field_set:fsm.proto.GearCommand.gear)
}

// -------------------------------------------------------------------

// TurnSignalCommand

// .fsm.proto.Timestamp stamp = 1;
inline bool TurnSignalCommand::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool TurnSignalCommand::has_stamp() const {
  return _internal_has_stamp();
}
inline void TurnSignalCommand::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& TurnSignalCommand::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& TurnSignalCommand::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TurnSignalCommand.stamp)
  return _internal_stamp();
}
inline void TurnSignalCommand::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TurnSignalCommand.stamp)
}
inline ::fsm::proto::Timestamp* TurnSignalCommand::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* TurnSignalCommand::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.TurnSignalCommand.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* TurnSignalCommand::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* TurnSignalCommand::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TurnSignalCommand.stamp)
  return _internal_mutable_stamp();
}
inline void TurnSignalCommand::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TurnSignalCommand.stamp)
}

// .fsm.proto.TurnSignal signal = 2;
inline void TurnSignalCommand::clear_signal() {
  signal_ = 0;
}
inline ::fsm::proto::TurnSignal TurnSignalCommand::_internal_signal() const {
  return static_cast< ::fsm::proto::TurnSignal >(signal_);
}
inline ::fsm::proto::TurnSignal TurnSignalCommand::signal() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TurnSignalCommand.signal)
  return _internal_signal();
}
inline void TurnSignalCommand::_internal_set_signal(::fsm::proto::TurnSignal value) {
  
  signal_ = value;
}
inline void TurnSignalCommand::set_signal(::fsm::proto::TurnSignal value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:fsm.proto.TurnSignalCommand.signal)
}

// -------------------------------------------------------------------

// EmergencyCommand

// .fsm.proto.Timestamp stamp = 1;
inline bool EmergencyCommand::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool EmergencyCommand::has_stamp() const {
  return _internal_has_stamp();
}
inline void EmergencyCommand::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& EmergencyCommand::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& EmergencyCommand::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.EmergencyCommand.stamp)
  return _internal_stamp();
}
inline void EmergencyCommand::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.EmergencyCommand.stamp)
}
inline ::fsm::proto::Timestamp* EmergencyCommand::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* EmergencyCommand::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.EmergencyCommand.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* EmergencyCommand::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* EmergencyCommand::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.EmergencyCommand.stamp)
  return _internal_mutable_stamp();
}
inline void EmergencyCommand::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.EmergencyCommand.stamp)
}

// bool emergency = 2;
inline void EmergencyCommand::clear_emergency() {
  emergency_ = false;
}
inline bool EmergencyCommand::_internal_emergency() const {
  return emergency_;
}
inline bool EmergencyCommand::emergency() const {
  // @@protoc_insertion_point(field_get:fsm.proto.EmergencyCommand.emergency)
  return _internal_emergency();
}
inline void EmergencyCommand::_internal_set_emergency(bool value) {
  
  emergency_ = value;
}
inline void EmergencyCommand::set_emergency(bool value) {
  _internal_set_emergency(value);
  // @@protoc_insertion_point(field_set:fsm.proto.EmergencyCommand.emergency)
}

// string reason = 3;
inline void EmergencyCommand::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EmergencyCommand::reason() const {
  // @@protoc_insertion_point(field_get:fsm.proto.EmergencyCommand.reason)
  return _internal_reason();
}
inline void EmergencyCommand::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:fsm.proto.EmergencyCommand.reason)
}
inline std::string* EmergencyCommand::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.EmergencyCommand.reason)
  return _internal_mutable_reason();
}
inline const std::string& EmergencyCommand::_internal_reason() const {
  return reason_.Get();
}
inline void EmergencyCommand::_internal_set_reason(const std::string& value) {
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EmergencyCommand::set_reason(std::string&& value) {
  
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.EmergencyCommand.reason)
}
inline void EmergencyCommand::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.EmergencyCommand.reason)
}
inline void EmergencyCommand::set_reason(const char* value,
    size_t size) {
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.EmergencyCommand.reason)
}
inline std::string* EmergencyCommand::_internal_mutable_reason() {
  
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EmergencyCommand::release_reason() {
  // @@protoc_insertion_point(field_release:fsm.proto.EmergencyCommand.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EmergencyCommand::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.EmergencyCommand.reason)
}
inline std::string* EmergencyCommand::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.EmergencyCommand.reason)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void EmergencyCommand::unsafe_arena_set_allocated_reason(
    std::string* reason) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reason, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.EmergencyCommand.reason)
}

// -------------------------------------------------------------------

// ControlCommand

// .fsm.proto.Timestamp stamp = 1;
inline bool ControlCommand::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool ControlCommand::has_stamp() const {
  return _internal_has_stamp();
}
inline void ControlCommand::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& ControlCommand::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& ControlCommand::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.stamp)
  return _internal_stamp();
}
inline void ControlCommand::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.stamp)
}
inline ::fsm::proto::Timestamp* ControlCommand::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* ControlCommand::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* ControlCommand::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* ControlCommand::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.stamp)
  return _internal_mutable_stamp();
}
inline void ControlCommand::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.stamp)
}

// string vehicle_id = 2;
inline void ControlCommand::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlCommand::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.vehicle_id)
  return _internal_vehicle_id();
}
inline void ControlCommand::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ControlCommand.vehicle_id)
}
inline std::string* ControlCommand::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& ControlCommand::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void ControlCommand::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlCommand::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.ControlCommand.vehicle_id)
}
inline void ControlCommand::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.ControlCommand.vehicle_id)
}
inline void ControlCommand::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.ControlCommand.vehicle_id)
}
inline std::string* ControlCommand::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlCommand::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlCommand::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.vehicle_id)
}
inline std::string* ControlCommand::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.ControlCommand.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControlCommand::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.vehicle_id)
}

// string operator_id = 3;
inline void ControlCommand::clear_operator_id() {
  operator_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControlCommand::operator_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.operator_id)
  return _internal_operator_id();
}
inline void ControlCommand::set_operator_id(const std::string& value) {
  _internal_set_operator_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ControlCommand.operator_id)
}
inline std::string* ControlCommand::mutable_operator_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.operator_id)
  return _internal_mutable_operator_id();
}
inline const std::string& ControlCommand::_internal_operator_id() const {
  return operator_id_.Get();
}
inline void ControlCommand::_internal_set_operator_id(const std::string& value) {
  
  operator_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControlCommand::set_operator_id(std::string&& value) {
  
  operator_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.ControlCommand.operator_id)
}
inline void ControlCommand::set_operator_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  operator_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.ControlCommand.operator_id)
}
inline void ControlCommand::set_operator_id(const char* value,
    size_t size) {
  
  operator_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.ControlCommand.operator_id)
}
inline std::string* ControlCommand::_internal_mutable_operator_id() {
  
  return operator_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControlCommand::release_operator_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.operator_id)
  return operator_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlCommand::set_allocated_operator_id(std::string* operator_id) {
  if (operator_id != nullptr) {
    
  } else {
    
  }
  operator_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operator_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.operator_id)
}
inline std::string* ControlCommand::unsafe_arena_release_operator_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.ControlCommand.operator_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return operator_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControlCommand::unsafe_arena_set_allocated_operator_id(
    std::string* operator_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (operator_id != nullptr) {
    
  } else {
    
  }
  operator_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      operator_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.operator_id)
}

// .fsm.proto.SteeringCommand steering = 4;
inline bool ControlCommand::_internal_has_steering() const {
  return this != internal_default_instance() && steering_ != nullptr;
}
inline bool ControlCommand::has_steering() const {
  return _internal_has_steering();
}
inline void ControlCommand::clear_steering() {
  if (GetArena() == nullptr && steering_ != nullptr) {
    delete steering_;
  }
  steering_ = nullptr;
}
inline const ::fsm::proto::SteeringCommand& ControlCommand::_internal_steering() const {
  const ::fsm::proto::SteeringCommand* p = steering_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::SteeringCommand*>(
      &::fsm::proto::_SteeringCommand_default_instance_);
}
inline const ::fsm::proto::SteeringCommand& ControlCommand::steering() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.steering)
  return _internal_steering();
}
inline void ControlCommand::unsafe_arena_set_allocated_steering(
    ::fsm::proto::SteeringCommand* steering) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(steering_);
  }
  steering_ = steering;
  if (steering) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.steering)
}
inline ::fsm::proto::SteeringCommand* ControlCommand::release_steering() {
  auto temp = unsafe_arena_release_steering();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::SteeringCommand* ControlCommand::unsafe_arena_release_steering() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.steering)
  
  ::fsm::proto::SteeringCommand* temp = steering_;
  steering_ = nullptr;
  return temp;
}
inline ::fsm::proto::SteeringCommand* ControlCommand::_internal_mutable_steering() {
  
  if (steering_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::SteeringCommand>(GetArena());
    steering_ = p;
  }
  return steering_;
}
inline ::fsm::proto::SteeringCommand* ControlCommand::mutable_steering() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.steering)
  return _internal_mutable_steering();
}
inline void ControlCommand::set_allocated_steering(::fsm::proto::SteeringCommand* steering) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete steering_;
  }
  if (steering) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(steering);
    if (message_arena != submessage_arena) {
      steering = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering, submessage_arena);
    }
    
  } else {
    
  }
  steering_ = steering;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.steering)
}

// .fsm.proto.LongitudinalCommand longitudinal = 5;
inline bool ControlCommand::_internal_has_longitudinal() const {
  return this != internal_default_instance() && longitudinal_ != nullptr;
}
inline bool ControlCommand::has_longitudinal() const {
  return _internal_has_longitudinal();
}
inline void ControlCommand::clear_longitudinal() {
  if (GetArena() == nullptr && longitudinal_ != nullptr) {
    delete longitudinal_;
  }
  longitudinal_ = nullptr;
}
inline const ::fsm::proto::LongitudinalCommand& ControlCommand::_internal_longitudinal() const {
  const ::fsm::proto::LongitudinalCommand* p = longitudinal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::LongitudinalCommand*>(
      &::fsm::proto::_LongitudinalCommand_default_instance_);
}
inline const ::fsm::proto::LongitudinalCommand& ControlCommand::longitudinal() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.longitudinal)
  return _internal_longitudinal();
}
inline void ControlCommand::unsafe_arena_set_allocated_longitudinal(
    ::fsm::proto::LongitudinalCommand* longitudinal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(longitudinal_);
  }
  longitudinal_ = longitudinal;
  if (longitudinal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.longitudinal)
}
inline ::fsm::proto::LongitudinalCommand* ControlCommand::release_longitudinal() {
  auto temp = unsafe_arena_release_longitudinal();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::LongitudinalCommand* ControlCommand::unsafe_arena_release_longitudinal() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.longitudinal)
  
  ::fsm::proto::LongitudinalCommand* temp = longitudinal_;
  longitudinal_ = nullptr;
  return temp;
}
inline ::fsm::proto::LongitudinalCommand* ControlCommand::_internal_mutable_longitudinal() {
  
  if (longitudinal_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::LongitudinalCommand>(GetArena());
    longitudinal_ = p;
  }
  return longitudinal_;
}
inline ::fsm::proto::LongitudinalCommand* ControlCommand::mutable_longitudinal() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.longitudinal)
  return _internal_mutable_longitudinal();
}
inline void ControlCommand::set_allocated_longitudinal(::fsm::proto::LongitudinalCommand* longitudinal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete longitudinal_;
  }
  if (longitudinal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(longitudinal);
    if (message_arena != submessage_arena) {
      longitudinal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longitudinal, submessage_arena);
    }
    
  } else {
    
  }
  longitudinal_ = longitudinal;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.longitudinal)
}

// .fsm.proto.GearCommand gear = 6;
inline bool ControlCommand::_internal_has_gear() const {
  return this != internal_default_instance() && gear_ != nullptr;
}
inline bool ControlCommand::has_gear() const {
  return _internal_has_gear();
}
inline void ControlCommand::clear_gear() {
  if (GetArena() == nullptr && gear_ != nullptr) {
    delete gear_;
  }
  gear_ = nullptr;
}
inline const ::fsm::proto::GearCommand& ControlCommand::_internal_gear() const {
  const ::fsm::proto::GearCommand* p = gear_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::GearCommand*>(
      &::fsm::proto::_GearCommand_default_instance_);
}
inline const ::fsm::proto::GearCommand& ControlCommand::gear() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.gear)
  return _internal_gear();
}
inline void ControlCommand::unsafe_arena_set_allocated_gear(
    ::fsm::proto::GearCommand* gear) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gear_);
  }
  gear_ = gear;
  if (gear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.gear)
}
inline ::fsm::proto::GearCommand* ControlCommand::release_gear() {
  auto temp = unsafe_arena_release_gear();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::GearCommand* ControlCommand::unsafe_arena_release_gear() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.gear)
  
  ::fsm::proto::GearCommand* temp = gear_;
  gear_ = nullptr;
  return temp;
}
inline ::fsm::proto::GearCommand* ControlCommand::_internal_mutable_gear() {
  
  if (gear_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::GearCommand>(GetArena());
    gear_ = p;
  }
  return gear_;
}
inline ::fsm::proto::GearCommand* ControlCommand::mutable_gear() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.gear)
  return _internal_mutable_gear();
}
inline void ControlCommand::set_allocated_gear(::fsm::proto::GearCommand* gear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gear_;
  }
  if (gear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gear);
    if (message_arena != submessage_arena) {
      gear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gear, submessage_arena);
    }
    
  } else {
    
  }
  gear_ = gear;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.gear)
}

// .fsm.proto.TurnSignalCommand turn_signal = 7;
inline bool ControlCommand::_internal_has_turn_signal() const {
  return this != internal_default_instance() && turn_signal_ != nullptr;
}
inline bool ControlCommand::has_turn_signal() const {
  return _internal_has_turn_signal();
}
inline void ControlCommand::clear_turn_signal() {
  if (GetArena() == nullptr && turn_signal_ != nullptr) {
    delete turn_signal_;
  }
  turn_signal_ = nullptr;
}
inline const ::fsm::proto::TurnSignalCommand& ControlCommand::_internal_turn_signal() const {
  const ::fsm::proto::TurnSignalCommand* p = turn_signal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::TurnSignalCommand*>(
      &::fsm::proto::_TurnSignalCommand_default_instance_);
}
inline const ::fsm::proto::TurnSignalCommand& ControlCommand::turn_signal() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.turn_signal)
  return _internal_turn_signal();
}
inline void ControlCommand::unsafe_arena_set_allocated_turn_signal(
    ::fsm::proto::TurnSignalCommand* turn_signal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_signal_);
  }
  turn_signal_ = turn_signal;
  if (turn_signal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.turn_signal)
}
inline ::fsm::proto::TurnSignalCommand* ControlCommand::release_turn_signal() {
  auto temp = unsafe_arena_release_turn_signal();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::TurnSignalCommand* ControlCommand::unsafe_arena_release_turn_signal() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.turn_signal)
  
  ::fsm::proto::TurnSignalCommand* temp = turn_signal_;
  turn_signal_ = nullptr;
  return temp;
}
inline ::fsm::proto::TurnSignalCommand* ControlCommand::_internal_mutable_turn_signal() {
  
  if (turn_signal_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::TurnSignalCommand>(GetArena());
    turn_signal_ = p;
  }
  return turn_signal_;
}
inline ::fsm::proto::TurnSignalCommand* ControlCommand::mutable_turn_signal() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.turn_signal)
  return _internal_mutable_turn_signal();
}
inline void ControlCommand::set_allocated_turn_signal(::fsm::proto::TurnSignalCommand* turn_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete turn_signal_;
  }
  if (turn_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(turn_signal);
    if (message_arena != submessage_arena) {
      turn_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_signal, submessage_arena);
    }
    
  } else {
    
  }
  turn_signal_ = turn_signal;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.turn_signal)
}

// .fsm.proto.EmergencyCommand emergency = 8;
inline bool ControlCommand::_internal_has_emergency() const {
  return this != internal_default_instance() && emergency_ != nullptr;
}
inline bool ControlCommand::has_emergency() const {
  return _internal_has_emergency();
}
inline void ControlCommand::clear_emergency() {
  if (GetArena() == nullptr && emergency_ != nullptr) {
    delete emergency_;
  }
  emergency_ = nullptr;
}
inline const ::fsm::proto::EmergencyCommand& ControlCommand::_internal_emergency() const {
  const ::fsm::proto::EmergencyCommand* p = emergency_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::EmergencyCommand*>(
      &::fsm::proto::_EmergencyCommand_default_instance_);
}
inline const ::fsm::proto::EmergencyCommand& ControlCommand::emergency() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.emergency)
  return _internal_emergency();
}
inline void ControlCommand::unsafe_arena_set_allocated_emergency(
    ::fsm::proto::EmergencyCommand* emergency) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emergency_);
  }
  emergency_ = emergency;
  if (emergency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.ControlCommand.emergency)
}
inline ::fsm::proto::EmergencyCommand* ControlCommand::release_emergency() {
  auto temp = unsafe_arena_release_emergency();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::EmergencyCommand* ControlCommand::unsafe_arena_release_emergency() {
  // @@protoc_insertion_point(field_release:fsm.proto.ControlCommand.emergency)
  
  ::fsm::proto::EmergencyCommand* temp = emergency_;
  emergency_ = nullptr;
  return temp;
}
inline ::fsm::proto::EmergencyCommand* ControlCommand::_internal_mutable_emergency() {
  
  if (emergency_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::EmergencyCommand>(GetArena());
    emergency_ = p;
  }
  return emergency_;
}
inline ::fsm::proto::EmergencyCommand* ControlCommand::mutable_emergency() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.ControlCommand.emergency)
  return _internal_mutable_emergency();
}
inline void ControlCommand::set_allocated_emergency(::fsm::proto::EmergencyCommand* emergency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete emergency_;
  }
  if (emergency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(emergency);
    if (message_arena != submessage_arena) {
      emergency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emergency, submessage_arena);
    }
    
  } else {
    
  }
  emergency_ = emergency;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.ControlCommand.emergency)
}

// uint64 sequence_number = 9;
inline void ControlCommand::clear_sequence_number() {
  sequence_number_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ControlCommand::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ControlCommand::sequence_number() const {
  // @@protoc_insertion_point(field_get:fsm.proto.ControlCommand.sequence_number)
  return _internal_sequence_number();
}
inline void ControlCommand::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_number_ = value;
}
inline void ControlCommand::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:fsm.proto.ControlCommand.sequence_number)
}

// -------------------------------------------------------------------

// TelemetryData

// .fsm.proto.Timestamp stamp = 1;
inline bool TelemetryData::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool TelemetryData::has_stamp() const {
  return _internal_has_stamp();
}
inline void TelemetryData::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& TelemetryData::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& TelemetryData::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.stamp)
  return _internal_stamp();
}
inline void TelemetryData::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TelemetryData.stamp)
}
inline ::fsm::proto::Timestamp* TelemetryData::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* TelemetryData::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.TelemetryData.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* TelemetryData::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* TelemetryData::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TelemetryData.stamp)
  return _internal_mutable_stamp();
}
inline void TelemetryData::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TelemetryData.stamp)
}

// string vehicle_id = 2;
inline void TelemetryData::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TelemetryData::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.vehicle_id)
  return _internal_vehicle_id();
}
inline void TelemetryData::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.TelemetryData.vehicle_id)
}
inline std::string* TelemetryData::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TelemetryData.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& TelemetryData::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void TelemetryData::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TelemetryData::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.TelemetryData.vehicle_id)
}
inline void TelemetryData::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.TelemetryData.vehicle_id)
}
inline void TelemetryData::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.TelemetryData.vehicle_id)
}
inline std::string* TelemetryData::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TelemetryData::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.TelemetryData.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TelemetryData::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TelemetryData.vehicle_id)
}
inline std::string* TelemetryData::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.TelemetryData.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TelemetryData::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TelemetryData.vehicle_id)
}

// .fsm.proto.VehicleStatus vehicle_status = 3;
inline bool TelemetryData::_internal_has_vehicle_status() const {
  return this != internal_default_instance() && vehicle_status_ != nullptr;
}
inline bool TelemetryData::has_vehicle_status() const {
  return _internal_has_vehicle_status();
}
inline void TelemetryData::clear_vehicle_status() {
  if (GetArena() == nullptr && vehicle_status_ != nullptr) {
    delete vehicle_status_;
  }
  vehicle_status_ = nullptr;
}
inline const ::fsm::proto::VehicleStatus& TelemetryData::_internal_vehicle_status() const {
  const ::fsm::proto::VehicleStatus* p = vehicle_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::VehicleStatus*>(
      &::fsm::proto::_VehicleStatus_default_instance_);
}
inline const ::fsm::proto::VehicleStatus& TelemetryData::vehicle_status() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.vehicle_status)
  return _internal_vehicle_status();
}
inline void TelemetryData::unsafe_arena_set_allocated_vehicle_status(
    ::fsm::proto::VehicleStatus* vehicle_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_status_);
  }
  vehicle_status_ = vehicle_status;
  if (vehicle_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TelemetryData.vehicle_status)
}
inline ::fsm::proto::VehicleStatus* TelemetryData::release_vehicle_status() {
  auto temp = unsafe_arena_release_vehicle_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::VehicleStatus* TelemetryData::unsafe_arena_release_vehicle_status() {
  // @@protoc_insertion_point(field_release:fsm.proto.TelemetryData.vehicle_status)
  
  ::fsm::proto::VehicleStatus* temp = vehicle_status_;
  vehicle_status_ = nullptr;
  return temp;
}
inline ::fsm::proto::VehicleStatus* TelemetryData::_internal_mutable_vehicle_status() {
  
  if (vehicle_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::VehicleStatus>(GetArena());
    vehicle_status_ = p;
  }
  return vehicle_status_;
}
inline ::fsm::proto::VehicleStatus* TelemetryData::mutable_vehicle_status() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TelemetryData.vehicle_status)
  return _internal_mutable_vehicle_status();
}
inline void TelemetryData::set_allocated_vehicle_status(::fsm::proto::VehicleStatus* vehicle_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vehicle_status_;
  }
  if (vehicle_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vehicle_status);
    if (message_arena != submessage_arena) {
      vehicle_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_status, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_status_ = vehicle_status;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TelemetryData.vehicle_status)
}

// .fsm.proto.LocalizationState localization = 4;
inline bool TelemetryData::_internal_has_localization() const {
  return this != internal_default_instance() && localization_ != nullptr;
}
inline bool TelemetryData::has_localization() const {
  return _internal_has_localization();
}
inline void TelemetryData::clear_localization() {
  if (GetArena() == nullptr && localization_ != nullptr) {
    delete localization_;
  }
  localization_ = nullptr;
}
inline const ::fsm::proto::LocalizationState& TelemetryData::_internal_localization() const {
  const ::fsm::proto::LocalizationState* p = localization_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::LocalizationState*>(
      &::fsm::proto::_LocalizationState_default_instance_);
}
inline const ::fsm::proto::LocalizationState& TelemetryData::localization() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.localization)
  return _internal_localization();
}
inline void TelemetryData::unsafe_arena_set_allocated_localization(
    ::fsm::proto::LocalizationState* localization) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localization_);
  }
  localization_ = localization;
  if (localization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TelemetryData.localization)
}
inline ::fsm::proto::LocalizationState* TelemetryData::release_localization() {
  auto temp = unsafe_arena_release_localization();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::LocalizationState* TelemetryData::unsafe_arena_release_localization() {
  // @@protoc_insertion_point(field_release:fsm.proto.TelemetryData.localization)
  
  ::fsm::proto::LocalizationState* temp = localization_;
  localization_ = nullptr;
  return temp;
}
inline ::fsm::proto::LocalizationState* TelemetryData::_internal_mutable_localization() {
  
  if (localization_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::LocalizationState>(GetArena());
    localization_ = p;
  }
  return localization_;
}
inline ::fsm::proto::LocalizationState* TelemetryData::mutable_localization() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TelemetryData.localization)
  return _internal_mutable_localization();
}
inline void TelemetryData::set_allocated_localization(::fsm::proto::LocalizationState* localization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete localization_;
  }
  if (localization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(localization);
    if (message_arena != submessage_arena) {
      localization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    
  } else {
    
  }
  localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TelemetryData.localization)
}

// .fsm.proto.SystemStatus system_status = 5;
inline bool TelemetryData::_internal_has_system_status() const {
  return this != internal_default_instance() && system_status_ != nullptr;
}
inline bool TelemetryData::has_system_status() const {
  return _internal_has_system_status();
}
inline void TelemetryData::clear_system_status() {
  if (GetArena() == nullptr && system_status_ != nullptr) {
    delete system_status_;
  }
  system_status_ = nullptr;
}
inline const ::fsm::proto::SystemStatus& TelemetryData::_internal_system_status() const {
  const ::fsm::proto::SystemStatus* p = system_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::SystemStatus*>(
      &::fsm::proto::_SystemStatus_default_instance_);
}
inline const ::fsm::proto::SystemStatus& TelemetryData::system_status() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.system_status)
  return _internal_system_status();
}
inline void TelemetryData::unsafe_arena_set_allocated_system_status(
    ::fsm::proto::SystemStatus* system_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_status_);
  }
  system_status_ = system_status;
  if (system_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TelemetryData.system_status)
}
inline ::fsm::proto::SystemStatus* TelemetryData::release_system_status() {
  auto temp = unsafe_arena_release_system_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::SystemStatus* TelemetryData::unsafe_arena_release_system_status() {
  // @@protoc_insertion_point(field_release:fsm.proto.TelemetryData.system_status)
  
  ::fsm::proto::SystemStatus* temp = system_status_;
  system_status_ = nullptr;
  return temp;
}
inline ::fsm::proto::SystemStatus* TelemetryData::_internal_mutable_system_status() {
  
  if (system_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::SystemStatus>(GetArena());
    system_status_ = p;
  }
  return system_status_;
}
inline ::fsm::proto::SystemStatus* TelemetryData::mutable_system_status() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TelemetryData.system_status)
  return _internal_mutable_system_status();
}
inline void TelemetryData::set_allocated_system_status(::fsm::proto::SystemStatus* system_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete system_status_;
  }
  if (system_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(system_status);
    if (message_arena != submessage_arena) {
      system_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_status, submessage_arena);
    }
    
  } else {
    
  }
  system_status_ = system_status;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TelemetryData.system_status)
}

// .fsm.proto.ConnectionStatus connection = 6;
inline bool TelemetryData::_internal_has_connection() const {
  return this != internal_default_instance() && connection_ != nullptr;
}
inline bool TelemetryData::has_connection() const {
  return _internal_has_connection();
}
inline void TelemetryData::clear_connection() {
  if (GetArena() == nullptr && connection_ != nullptr) {
    delete connection_;
  }
  connection_ = nullptr;
}
inline const ::fsm::proto::ConnectionStatus& TelemetryData::_internal_connection() const {
  const ::fsm::proto::ConnectionStatus* p = connection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::ConnectionStatus*>(
      &::fsm::proto::_ConnectionStatus_default_instance_);
}
inline const ::fsm::proto::ConnectionStatus& TelemetryData::connection() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.connection)
  return _internal_connection();
}
inline void TelemetryData::unsafe_arena_set_allocated_connection(
    ::fsm::proto::ConnectionStatus* connection) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_);
  }
  connection_ = connection;
  if (connection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.TelemetryData.connection)
}
inline ::fsm::proto::ConnectionStatus* TelemetryData::release_connection() {
  auto temp = unsafe_arena_release_connection();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::ConnectionStatus* TelemetryData::unsafe_arena_release_connection() {
  // @@protoc_insertion_point(field_release:fsm.proto.TelemetryData.connection)
  
  ::fsm::proto::ConnectionStatus* temp = connection_;
  connection_ = nullptr;
  return temp;
}
inline ::fsm::proto::ConnectionStatus* TelemetryData::_internal_mutable_connection() {
  
  if (connection_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::ConnectionStatus>(GetArena());
    connection_ = p;
  }
  return connection_;
}
inline ::fsm::proto::ConnectionStatus* TelemetryData::mutable_connection() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.TelemetryData.connection)
  return _internal_mutable_connection();
}
inline void TelemetryData::set_allocated_connection(::fsm::proto::ConnectionStatus* connection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete connection_;
  }
  if (connection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(connection);
    if (message_arena != submessage_arena) {
      connection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    
  } else {
    
  }
  connection_ = connection;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.TelemetryData.connection)
}

// uint64 sequence_number = 7;
inline void TelemetryData::clear_sequence_number() {
  sequence_number_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TelemetryData::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TelemetryData::sequence_number() const {
  // @@protoc_insertion_point(field_get:fsm.proto.TelemetryData.sequence_number)
  return _internal_sequence_number();
}
inline void TelemetryData::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_number_ = value;
}
inline void TelemetryData::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:fsm.proto.TelemetryData.sequence_number)
}

// -------------------------------------------------------------------

// VehicleSchedulingInfo

// string vehicle_id = 1;
inline void VehicleSchedulingInfo::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VehicleSchedulingInfo::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.vehicle_id)
  return _internal_vehicle_id();
}
inline void VehicleSchedulingInfo::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.vehicle_id)
}
inline std::string* VehicleSchedulingInfo::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleSchedulingInfo.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& VehicleSchedulingInfo::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void VehicleSchedulingInfo::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VehicleSchedulingInfo::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.VehicleSchedulingInfo.vehicle_id)
}
inline void VehicleSchedulingInfo::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.VehicleSchedulingInfo.vehicle_id)
}
inline void VehicleSchedulingInfo::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.VehicleSchedulingInfo.vehicle_id)
}
inline std::string* VehicleSchedulingInfo::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VehicleSchedulingInfo::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleSchedulingInfo.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VehicleSchedulingInfo::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleSchedulingInfo.vehicle_id)
}
inline std::string* VehicleSchedulingInfo::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.VehicleSchedulingInfo.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VehicleSchedulingInfo::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleSchedulingInfo.vehicle_id)
}

// .fsm.proto.VehicleTaskStatus task_status = 2;
inline void VehicleSchedulingInfo::clear_task_status() {
  task_status_ = 0;
}
inline ::fsm::proto::VehicleTaskStatus VehicleSchedulingInfo::_internal_task_status() const {
  return static_cast< ::fsm::proto::VehicleTaskStatus >(task_status_);
}
inline ::fsm::proto::VehicleTaskStatus VehicleSchedulingInfo::task_status() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.task_status)
  return _internal_task_status();
}
inline void VehicleSchedulingInfo::_internal_set_task_status(::fsm::proto::VehicleTaskStatus value) {
  
  task_status_ = value;
}
inline void VehicleSchedulingInfo::set_task_status(::fsm::proto::VehicleTaskStatus value) {
  _internal_set_task_status(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.task_status)
}

// .fsm.proto.EmergencyLevel emergency_level = 3;
inline void VehicleSchedulingInfo::clear_emergency_level() {
  emergency_level_ = 0;
}
inline ::fsm::proto::EmergencyLevel VehicleSchedulingInfo::_internal_emergency_level() const {
  return static_cast< ::fsm::proto::EmergencyLevel >(emergency_level_);
}
inline ::fsm::proto::EmergencyLevel VehicleSchedulingInfo::emergency_level() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.emergency_level)
  return _internal_emergency_level();
}
inline void VehicleSchedulingInfo::_internal_set_emergency_level(::fsm::proto::EmergencyLevel value) {
  
  emergency_level_ = value;
}
inline void VehicleSchedulingInfo::set_emergency_level(::fsm::proto::EmergencyLevel value) {
  _internal_set_emergency_level(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.emergency_level)
}

// float priority_score = 4;
inline void VehicleSchedulingInfo::clear_priority_score() {
  priority_score_ = 0;
}
inline float VehicleSchedulingInfo::_internal_priority_score() const {
  return priority_score_;
}
inline float VehicleSchedulingInfo::priority_score() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.priority_score)
  return _internal_priority_score();
}
inline void VehicleSchedulingInfo::_internal_set_priority_score(float value) {
  
  priority_score_ = value;
}
inline void VehicleSchedulingInfo::set_priority_score(float value) {
  _internal_set_priority_score(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.priority_score)
}

// .fsm.proto.GeoPoint location = 5;
inline bool VehicleSchedulingInfo::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool VehicleSchedulingInfo::has_location() const {
  return _internal_has_location();
}
inline void VehicleSchedulingInfo::clear_location() {
  if (GetArena() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::fsm::proto::GeoPoint& VehicleSchedulingInfo::_internal_location() const {
  const ::fsm::proto::GeoPoint* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::GeoPoint*>(
      &::fsm::proto::_GeoPoint_default_instance_);
}
inline const ::fsm::proto::GeoPoint& VehicleSchedulingInfo::location() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.location)
  return _internal_location();
}
inline void VehicleSchedulingInfo::unsafe_arena_set_allocated_location(
    ::fsm::proto::GeoPoint* location) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleSchedulingInfo.location)
}
inline ::fsm::proto::GeoPoint* VehicleSchedulingInfo::release_location() {
  auto temp = unsafe_arena_release_location();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::GeoPoint* VehicleSchedulingInfo::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleSchedulingInfo.location)
  
  ::fsm::proto::GeoPoint* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::fsm::proto::GeoPoint* VehicleSchedulingInfo::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::GeoPoint>(GetArena());
    location_ = p;
  }
  return location_;
}
inline ::fsm::proto::GeoPoint* VehicleSchedulingInfo::mutable_location() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleSchedulingInfo.location)
  return _internal_mutable_location();
}
inline void VehicleSchedulingInfo::set_allocated_location(::fsm::proto::GeoPoint* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleSchedulingInfo.location)
}

// float latency_ms = 6;
inline void VehicleSchedulingInfo::clear_latency_ms() {
  latency_ms_ = 0;
}
inline float VehicleSchedulingInfo::_internal_latency_ms() const {
  return latency_ms_;
}
inline float VehicleSchedulingInfo::latency_ms() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.latency_ms)
  return _internal_latency_ms();
}
inline void VehicleSchedulingInfo::_internal_set_latency_ms(float value) {
  
  latency_ms_ = value;
}
inline void VehicleSchedulingInfo::set_latency_ms(float value) {
  _internal_set_latency_ms(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.latency_ms)
}

// float battery_level = 7;
inline void VehicleSchedulingInfo::clear_battery_level() {
  battery_level_ = 0;
}
inline float VehicleSchedulingInfo::_internal_battery_level() const {
  return battery_level_;
}
inline float VehicleSchedulingInfo::battery_level() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.battery_level)
  return _internal_battery_level();
}
inline void VehicleSchedulingInfo::_internal_set_battery_level(float value) {
  
  battery_level_ = value;
}
inline void VehicleSchedulingInfo::set_battery_level(float value) {
  _internal_set_battery_level(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.battery_level)
}

// string current_task = 8;
inline void VehicleSchedulingInfo::clear_current_task() {
  current_task_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VehicleSchedulingInfo::current_task() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.current_task)
  return _internal_current_task();
}
inline void VehicleSchedulingInfo::set_current_task(const std::string& value) {
  _internal_set_current_task(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VehicleSchedulingInfo.current_task)
}
inline std::string* VehicleSchedulingInfo::mutable_current_task() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleSchedulingInfo.current_task)
  return _internal_mutable_current_task();
}
inline const std::string& VehicleSchedulingInfo::_internal_current_task() const {
  return current_task_.Get();
}
inline void VehicleSchedulingInfo::_internal_set_current_task(const std::string& value) {
  
  current_task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VehicleSchedulingInfo::set_current_task(std::string&& value) {
  
  current_task_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.VehicleSchedulingInfo.current_task)
}
inline void VehicleSchedulingInfo::set_current_task(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.VehicleSchedulingInfo.current_task)
}
inline void VehicleSchedulingInfo::set_current_task(const char* value,
    size_t size) {
  
  current_task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.VehicleSchedulingInfo.current_task)
}
inline std::string* VehicleSchedulingInfo::_internal_mutable_current_task() {
  
  return current_task_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VehicleSchedulingInfo::release_current_task() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleSchedulingInfo.current_task)
  return current_task_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VehicleSchedulingInfo::set_allocated_current_task(std::string* current_task) {
  if (current_task != nullptr) {
    
  } else {
    
  }
  current_task_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_task,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleSchedulingInfo.current_task)
}
inline std::string* VehicleSchedulingInfo::unsafe_arena_release_current_task() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.VehicleSchedulingInfo.current_task)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return current_task_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VehicleSchedulingInfo::unsafe_arena_set_allocated_current_task(
    std::string* current_task) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (current_task != nullptr) {
    
  } else {
    
  }
  current_task_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      current_task, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleSchedulingInfo.current_task)
}

// .fsm.proto.Timestamp last_update = 9;
inline bool VehicleSchedulingInfo::_internal_has_last_update() const {
  return this != internal_default_instance() && last_update_ != nullptr;
}
inline bool VehicleSchedulingInfo::has_last_update() const {
  return _internal_has_last_update();
}
inline void VehicleSchedulingInfo::clear_last_update() {
  if (GetArena() == nullptr && last_update_ != nullptr) {
    delete last_update_;
  }
  last_update_ = nullptr;
}
inline const ::fsm::proto::Timestamp& VehicleSchedulingInfo::_internal_last_update() const {
  const ::fsm::proto::Timestamp* p = last_update_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& VehicleSchedulingInfo::last_update() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VehicleSchedulingInfo.last_update)
  return _internal_last_update();
}
inline void VehicleSchedulingInfo::unsafe_arena_set_allocated_last_update(
    ::fsm::proto::Timestamp* last_update) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_update_);
  }
  last_update_ = last_update;
  if (last_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VehicleSchedulingInfo.last_update)
}
inline ::fsm::proto::Timestamp* VehicleSchedulingInfo::release_last_update() {
  auto temp = unsafe_arena_release_last_update();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* VehicleSchedulingInfo::unsafe_arena_release_last_update() {
  // @@protoc_insertion_point(field_release:fsm.proto.VehicleSchedulingInfo.last_update)
  
  ::fsm::proto::Timestamp* temp = last_update_;
  last_update_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* VehicleSchedulingInfo::_internal_mutable_last_update() {
  
  if (last_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    last_update_ = p;
  }
  return last_update_;
}
inline ::fsm::proto::Timestamp* VehicleSchedulingInfo::mutable_last_update() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VehicleSchedulingInfo.last_update)
  return _internal_mutable_last_update();
}
inline void VehicleSchedulingInfo::set_allocated_last_update(::fsm::proto::Timestamp* last_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete last_update_;
  }
  if (last_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(last_update);
    if (message_arena != submessage_arena) {
      last_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_update, submessage_arena);
    }
    
  } else {
    
  }
  last_update_ = last_update;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VehicleSchedulingInfo.last_update)
}

// -------------------------------------------------------------------

// SchedulingQueue

// .fsm.proto.Timestamp stamp = 1;
inline bool SchedulingQueue::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool SchedulingQueue::has_stamp() const {
  return _internal_has_stamp();
}
inline void SchedulingQueue::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& SchedulingQueue::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& SchedulingQueue::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SchedulingQueue.stamp)
  return _internal_stamp();
}
inline void SchedulingQueue::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.SchedulingQueue.stamp)
}
inline ::fsm::proto::Timestamp* SchedulingQueue::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* SchedulingQueue::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.SchedulingQueue.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* SchedulingQueue::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* SchedulingQueue::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SchedulingQueue.stamp)
  return _internal_mutable_stamp();
}
inline void SchedulingQueue::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.SchedulingQueue.stamp)
}

// repeated .fsm.proto.VehicleSchedulingInfo vehicles = 2;
inline int SchedulingQueue::_internal_vehicles_size() const {
  return vehicles_.size();
}
inline int SchedulingQueue::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void SchedulingQueue::clear_vehicles() {
  vehicles_.Clear();
}
inline ::fsm::proto::VehicleSchedulingInfo* SchedulingQueue::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SchedulingQueue.vehicles)
  return vehicles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::VehicleSchedulingInfo >*
SchedulingQueue::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:fsm.proto.SchedulingQueue.vehicles)
  return &vehicles_;
}
inline const ::fsm::proto::VehicleSchedulingInfo& SchedulingQueue::_internal_vehicles(int index) const {
  return vehicles_.Get(index);
}
inline const ::fsm::proto::VehicleSchedulingInfo& SchedulingQueue::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:fsm.proto.SchedulingQueue.vehicles)
  return _internal_vehicles(index);
}
inline ::fsm::proto::VehicleSchedulingInfo* SchedulingQueue::_internal_add_vehicles() {
  return vehicles_.Add();
}
inline ::fsm::proto::VehicleSchedulingInfo* SchedulingQueue::add_vehicles() {
  // @@protoc_insertion_point(field_add:fsm.proto.SchedulingQueue.vehicles)
  return _internal_add_vehicles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::VehicleSchedulingInfo >&
SchedulingQueue::vehicles() const {
  // @@protoc_insertion_point(field_list:fsm.proto.SchedulingQueue.vehicles)
  return vehicles_;
}

// string algorithm = 3;
inline void SchedulingQueue::clear_algorithm() {
  algorithm_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SchedulingQueue::algorithm() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SchedulingQueue.algorithm)
  return _internal_algorithm();
}
inline void SchedulingQueue::set_algorithm(const std::string& value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SchedulingQueue.algorithm)
}
inline std::string* SchedulingQueue::mutable_algorithm() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.SchedulingQueue.algorithm)
  return _internal_mutable_algorithm();
}
inline const std::string& SchedulingQueue::_internal_algorithm() const {
  return algorithm_.Get();
}
inline void SchedulingQueue::_internal_set_algorithm(const std::string& value) {
  
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SchedulingQueue::set_algorithm(std::string&& value) {
  
  algorithm_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.SchedulingQueue.algorithm)
}
inline void SchedulingQueue::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.SchedulingQueue.algorithm)
}
inline void SchedulingQueue::set_algorithm(const char* value,
    size_t size) {
  
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.SchedulingQueue.algorithm)
}
inline std::string* SchedulingQueue::_internal_mutable_algorithm() {
  
  return algorithm_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SchedulingQueue::release_algorithm() {
  // @@protoc_insertion_point(field_release:fsm.proto.SchedulingQueue.algorithm)
  return algorithm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SchedulingQueue::set_allocated_algorithm(std::string* algorithm) {
  if (algorithm != nullptr) {
    
  } else {
    
  }
  algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), algorithm,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.SchedulingQueue.algorithm)
}
inline std::string* SchedulingQueue::unsafe_arena_release_algorithm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.SchedulingQueue.algorithm)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return algorithm_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SchedulingQueue::unsafe_arena_set_allocated_algorithm(
    std::string* algorithm) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (algorithm != nullptr) {
    
  } else {
    
  }
  algorithm_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      algorithm, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.SchedulingQueue.algorithm)
}

// bool scheduling_enabled = 4;
inline void SchedulingQueue::clear_scheduling_enabled() {
  scheduling_enabled_ = false;
}
inline bool SchedulingQueue::_internal_scheduling_enabled() const {
  return scheduling_enabled_;
}
inline bool SchedulingQueue::scheduling_enabled() const {
  // @@protoc_insertion_point(field_get:fsm.proto.SchedulingQueue.scheduling_enabled)
  return _internal_scheduling_enabled();
}
inline void SchedulingQueue::_internal_set_scheduling_enabled(bool value) {
  
  scheduling_enabled_ = value;
}
inline void SchedulingQueue::set_scheduling_enabled(bool value) {
  _internal_set_scheduling_enabled(value);
  // @@protoc_insertion_point(field_set:fsm.proto.SchedulingQueue.scheduling_enabled)
}

// -------------------------------------------------------------------

// Alert

// .fsm.proto.Timestamp stamp = 1;
inline bool Alert::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool Alert::has_stamp() const {
  return _internal_has_stamp();
}
inline void Alert::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& Alert::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& Alert::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.stamp)
  return _internal_stamp();
}
inline void Alert::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.stamp)
}
inline ::fsm::proto::Timestamp* Alert::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* Alert::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* Alert::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* Alert::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.stamp)
  return _internal_mutable_stamp();
}
inline void Alert::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.stamp)
}

// string id = 2;
inline void Alert::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Alert::id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.id)
  return _internal_id();
}
inline void Alert::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.id)
}
inline std::string* Alert::mutable_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.id)
  return _internal_mutable_id();
}
inline const std::string& Alert::_internal_id() const {
  return id_.Get();
}
inline void Alert::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Alert::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.Alert.id)
}
inline void Alert::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.Alert.id)
}
inline void Alert::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.Alert.id)
}
inline std::string* Alert::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Alert::release_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Alert::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.id)
}
inline std::string* Alert::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.Alert.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Alert::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.id)
}

// string vehicle_id = 3;
inline void Alert::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Alert::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.vehicle_id)
  return _internal_vehicle_id();
}
inline void Alert::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.vehicle_id)
}
inline std::string* Alert::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& Alert::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void Alert::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Alert::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.Alert.vehicle_id)
}
inline void Alert::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.Alert.vehicle_id)
}
inline void Alert::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.Alert.vehicle_id)
}
inline std::string* Alert::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Alert::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Alert::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.vehicle_id)
}
inline std::string* Alert::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.Alert.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Alert::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.vehicle_id)
}

// .fsm.proto.AlertType type = 4;
inline void Alert::clear_type() {
  type_ = 0;
}
inline ::fsm::proto::AlertType Alert::_internal_type() const {
  return static_cast< ::fsm::proto::AlertType >(type_);
}
inline ::fsm::proto::AlertType Alert::type() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.type)
  return _internal_type();
}
inline void Alert::_internal_set_type(::fsm::proto::AlertType value) {
  
  type_ = value;
}
inline void Alert::set_type(::fsm::proto::AlertType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.type)
}

// .fsm.proto.AlertSeverity severity = 5;
inline void Alert::clear_severity() {
  severity_ = 0;
}
inline ::fsm::proto::AlertSeverity Alert::_internal_severity() const {
  return static_cast< ::fsm::proto::AlertSeverity >(severity_);
}
inline ::fsm::proto::AlertSeverity Alert::severity() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.severity)
  return _internal_severity();
}
inline void Alert::_internal_set_severity(::fsm::proto::AlertSeverity value) {
  
  severity_ = value;
}
inline void Alert::set_severity(::fsm::proto::AlertSeverity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.severity)
}

// string title = 6;
inline void Alert::clear_title() {
  title_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Alert::title() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.title)
  return _internal_title();
}
inline void Alert::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.title)
}
inline std::string* Alert::mutable_title() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.title)
  return _internal_mutable_title();
}
inline const std::string& Alert::_internal_title() const {
  return title_.Get();
}
inline void Alert::_internal_set_title(const std::string& value) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Alert::set_title(std::string&& value) {
  
  title_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.Alert.title)
}
inline void Alert::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.Alert.title)
}
inline void Alert::set_title(const char* value,
    size_t size) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.Alert.title)
}
inline std::string* Alert::_internal_mutable_title() {
  
  return title_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Alert::release_title() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Alert::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.title)
}
inline std::string* Alert::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.Alert.title)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return title_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Alert::unsafe_arena_set_allocated_title(
    std::string* title) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (title != nullptr) {
    
  } else {
    
  }
  title_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      title, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.title)
}

// string message = 7;
inline void Alert::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Alert::message() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.message)
  return _internal_message();
}
inline void Alert::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.message)
}
inline std::string* Alert::mutable_message() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.message)
  return _internal_mutable_message();
}
inline const std::string& Alert::_internal_message() const {
  return message_.Get();
}
inline void Alert::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Alert::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.Alert.message)
}
inline void Alert::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.Alert.message)
}
inline void Alert::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.Alert.message)
}
inline std::string* Alert::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Alert::release_message() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Alert::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.message)
}
inline std::string* Alert::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.Alert.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Alert::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.message)
}

// bool acknowledged = 8;
inline void Alert::clear_acknowledged() {
  acknowledged_ = false;
}
inline bool Alert::_internal_acknowledged() const {
  return acknowledged_;
}
inline bool Alert::acknowledged() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.acknowledged)
  return _internal_acknowledged();
}
inline void Alert::_internal_set_acknowledged(bool value) {
  
  acknowledged_ = value;
}
inline void Alert::set_acknowledged(bool value) {
  _internal_set_acknowledged(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.acknowledged)
}

// .fsm.proto.Timestamp ack_time = 9;
inline bool Alert::_internal_has_ack_time() const {
  return this != internal_default_instance() && ack_time_ != nullptr;
}
inline bool Alert::has_ack_time() const {
  return _internal_has_ack_time();
}
inline void Alert::clear_ack_time() {
  if (GetArena() == nullptr && ack_time_ != nullptr) {
    delete ack_time_;
  }
  ack_time_ = nullptr;
}
inline const ::fsm::proto::Timestamp& Alert::_internal_ack_time() const {
  const ::fsm::proto::Timestamp* p = ack_time_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& Alert::ack_time() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.ack_time)
  return _internal_ack_time();
}
inline void Alert::unsafe_arena_set_allocated_ack_time(
    ::fsm::proto::Timestamp* ack_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_time_);
  }
  ack_time_ = ack_time;
  if (ack_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.ack_time)
}
inline ::fsm::proto::Timestamp* Alert::release_ack_time() {
  auto temp = unsafe_arena_release_ack_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* Alert::unsafe_arena_release_ack_time() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.ack_time)
  
  ::fsm::proto::Timestamp* temp = ack_time_;
  ack_time_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* Alert::_internal_mutable_ack_time() {
  
  if (ack_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    ack_time_ = p;
  }
  return ack_time_;
}
inline ::fsm::proto::Timestamp* Alert::mutable_ack_time() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.ack_time)
  return _internal_mutable_ack_time();
}
inline void Alert::set_allocated_ack_time(::fsm::proto::Timestamp* ack_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ack_time_;
  }
  if (ack_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ack_time);
    if (message_arena != submessage_arena) {
      ack_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack_time, submessage_arena);
    }
    
  } else {
    
  }
  ack_time_ = ack_time;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.ack_time)
}

// string ack_by = 10;
inline void Alert::clear_ack_by() {
  ack_by_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Alert::ack_by() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Alert.ack_by)
  return _internal_ack_by();
}
inline void Alert::set_ack_by(const std::string& value) {
  _internal_set_ack_by(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Alert.ack_by)
}
inline std::string* Alert::mutable_ack_by() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Alert.ack_by)
  return _internal_mutable_ack_by();
}
inline const std::string& Alert::_internal_ack_by() const {
  return ack_by_.Get();
}
inline void Alert::_internal_set_ack_by(const std::string& value) {
  
  ack_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Alert::set_ack_by(std::string&& value) {
  
  ack_by_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.Alert.ack_by)
}
inline void Alert::set_ack_by(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ack_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.Alert.ack_by)
}
inline void Alert::set_ack_by(const char* value,
    size_t size) {
  
  ack_by_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.Alert.ack_by)
}
inline std::string* Alert::_internal_mutable_ack_by() {
  
  return ack_by_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Alert::release_ack_by() {
  // @@protoc_insertion_point(field_release:fsm.proto.Alert.ack_by)
  return ack_by_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Alert::set_allocated_ack_by(std::string* ack_by) {
  if (ack_by != nullptr) {
    
  } else {
    
  }
  ack_by_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ack_by,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Alert.ack_by)
}
inline std::string* Alert::unsafe_arena_release_ack_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.Alert.ack_by)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ack_by_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Alert::unsafe_arena_set_allocated_ack_by(
    std::string* ack_by) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ack_by != nullptr) {
    
  } else {
    
  }
  ack_by_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ack_by, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Alert.ack_by)
}

// -------------------------------------------------------------------

// PredictedTrajectoryPoint

// .fsm.proto.Pose pose = 1;
inline bool PredictedTrajectoryPoint::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool PredictedTrajectoryPoint::has_pose() const {
  return _internal_has_pose();
}
inline void PredictedTrajectoryPoint::clear_pose() {
  if (GetArena() == nullptr && pose_ != nullptr) {
    delete pose_;
  }
  pose_ = nullptr;
}
inline const ::fsm::proto::Pose& PredictedTrajectoryPoint::_internal_pose() const {
  const ::fsm::proto::Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Pose*>(
      &::fsm::proto::_Pose_default_instance_);
}
inline const ::fsm::proto::Pose& PredictedTrajectoryPoint::pose() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectoryPoint.pose)
  return _internal_pose();
}
inline void PredictedTrajectoryPoint::unsafe_arena_set_allocated_pose(
    ::fsm::proto::Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.PredictedTrajectoryPoint.pose)
}
inline ::fsm::proto::Pose* PredictedTrajectoryPoint::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Pose* PredictedTrajectoryPoint::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:fsm.proto.PredictedTrajectoryPoint.pose)
  
  ::fsm::proto::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::fsm::proto::Pose* PredictedTrajectoryPoint::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::fsm::proto::Pose* PredictedTrajectoryPoint::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.PredictedTrajectoryPoint.pose)
  return _internal_mutable_pose();
}
inline void PredictedTrajectoryPoint::set_allocated_pose(::fsm::proto::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.PredictedTrajectoryPoint.pose)
}

// float velocity = 2;
inline void PredictedTrajectoryPoint::clear_velocity() {
  velocity_ = 0;
}
inline float PredictedTrajectoryPoint::_internal_velocity() const {
  return velocity_;
}
inline float PredictedTrajectoryPoint::velocity() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectoryPoint.velocity)
  return _internal_velocity();
}
inline void PredictedTrajectoryPoint::_internal_set_velocity(float value) {
  
  velocity_ = value;
}
inline void PredictedTrajectoryPoint::set_velocity(float value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:fsm.proto.PredictedTrajectoryPoint.velocity)
}

// float acceleration = 3;
inline void PredictedTrajectoryPoint::clear_acceleration() {
  acceleration_ = 0;
}
inline float PredictedTrajectoryPoint::_internal_acceleration() const {
  return acceleration_;
}
inline float PredictedTrajectoryPoint::acceleration() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectoryPoint.acceleration)
  return _internal_acceleration();
}
inline void PredictedTrajectoryPoint::_internal_set_acceleration(float value) {
  
  acceleration_ = value;
}
inline void PredictedTrajectoryPoint::set_acceleration(float value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:fsm.proto.PredictedTrajectoryPoint.acceleration)
}

// float time_from_start = 4;
inline void PredictedTrajectoryPoint::clear_time_from_start() {
  time_from_start_ = 0;
}
inline float PredictedTrajectoryPoint::_internal_time_from_start() const {
  return time_from_start_;
}
inline float PredictedTrajectoryPoint::time_from_start() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectoryPoint.time_from_start)
  return _internal_time_from_start();
}
inline void PredictedTrajectoryPoint::_internal_set_time_from_start(float value) {
  
  time_from_start_ = value;
}
inline void PredictedTrajectoryPoint::set_time_from_start(float value) {
  _internal_set_time_from_start(value);
  // @@protoc_insertion_point(field_set:fsm.proto.PredictedTrajectoryPoint.time_from_start)
}

// -------------------------------------------------------------------

// PredictedTrajectory

// .fsm.proto.Timestamp stamp = 1;
inline bool PredictedTrajectory::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool PredictedTrajectory::has_stamp() const {
  return _internal_has_stamp();
}
inline void PredictedTrajectory::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& PredictedTrajectory::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& PredictedTrajectory::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectory.stamp)
  return _internal_stamp();
}
inline void PredictedTrajectory::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.PredictedTrajectory.stamp)
}
inline ::fsm::proto::Timestamp* PredictedTrajectory::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* PredictedTrajectory::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.PredictedTrajectory.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* PredictedTrajectory::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* PredictedTrajectory::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.PredictedTrajectory.stamp)
  return _internal_mutable_stamp();
}
inline void PredictedTrajectory::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.PredictedTrajectory.stamp)
}

// string vehicle_id = 2;
inline void PredictedTrajectory::clear_vehicle_id() {
  vehicle_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PredictedTrajectory::vehicle_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectory.vehicle_id)
  return _internal_vehicle_id();
}
inline void PredictedTrajectory::set_vehicle_id(const std::string& value) {
  _internal_set_vehicle_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.PredictedTrajectory.vehicle_id)
}
inline std::string* PredictedTrajectory::mutable_vehicle_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.PredictedTrajectory.vehicle_id)
  return _internal_mutable_vehicle_id();
}
inline const std::string& PredictedTrajectory::_internal_vehicle_id() const {
  return vehicle_id_.Get();
}
inline void PredictedTrajectory::_internal_set_vehicle_id(const std::string& value) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PredictedTrajectory::set_vehicle_id(std::string&& value) {
  
  vehicle_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.PredictedTrajectory.vehicle_id)
}
inline void PredictedTrajectory::set_vehicle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.PredictedTrajectory.vehicle_id)
}
inline void PredictedTrajectory::set_vehicle_id(const char* value,
    size_t size) {
  
  vehicle_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.PredictedTrajectory.vehicle_id)
}
inline std::string* PredictedTrajectory::_internal_mutable_vehicle_id() {
  
  return vehicle_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PredictedTrajectory::release_vehicle_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.PredictedTrajectory.vehicle_id)
  return vehicle_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PredictedTrajectory::set_allocated_vehicle_id(std::string* vehicle_id) {
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vehicle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.PredictedTrajectory.vehicle_id)
}
inline std::string* PredictedTrajectory::unsafe_arena_release_vehicle_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.PredictedTrajectory.vehicle_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vehicle_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PredictedTrajectory::unsafe_arena_set_allocated_vehicle_id(
    std::string* vehicle_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vehicle_id != nullptr) {
    
  } else {
    
  }
  vehicle_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vehicle_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.PredictedTrajectory.vehicle_id)
}

// repeated .fsm.proto.PredictedTrajectoryPoint points = 3;
inline int PredictedTrajectory::_internal_points_size() const {
  return points_.size();
}
inline int PredictedTrajectory::points_size() const {
  return _internal_points_size();
}
inline void PredictedTrajectory::clear_points() {
  points_.Clear();
}
inline ::fsm::proto::PredictedTrajectoryPoint* PredictedTrajectory::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:fsm.proto.PredictedTrajectory.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::PredictedTrajectoryPoint >*
PredictedTrajectory::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:fsm.proto.PredictedTrajectory.points)
  return &points_;
}
inline const ::fsm::proto::PredictedTrajectoryPoint& PredictedTrajectory::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::fsm::proto::PredictedTrajectoryPoint& PredictedTrajectory::points(int index) const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectory.points)
  return _internal_points(index);
}
inline ::fsm::proto::PredictedTrajectoryPoint* PredictedTrajectory::_internal_add_points() {
  return points_.Add();
}
inline ::fsm::proto::PredictedTrajectoryPoint* PredictedTrajectory::add_points() {
  // @@protoc_insertion_point(field_add:fsm.proto.PredictedTrajectory.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fsm::proto::PredictedTrajectoryPoint >&
PredictedTrajectory::points() const {
  // @@protoc_insertion_point(field_list:fsm.proto.PredictedTrajectory.points)
  return points_;
}

// float confidence = 4;
inline void PredictedTrajectory::clear_confidence() {
  confidence_ = 0;
}
inline float PredictedTrajectory::_internal_confidence() const {
  return confidence_;
}
inline float PredictedTrajectory::confidence() const {
  // @@protoc_insertion_point(field_get:fsm.proto.PredictedTrajectory.confidence)
  return _internal_confidence();
}
inline void PredictedTrajectory::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void PredictedTrajectory::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:fsm.proto.PredictedTrajectory.confidence)
}

// -------------------------------------------------------------------

// LatencyCompensation

// .fsm.proto.Timestamp stamp = 1;
inline bool LatencyCompensation::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool LatencyCompensation::has_stamp() const {
  return _internal_has_stamp();
}
inline void LatencyCompensation::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& LatencyCompensation::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& LatencyCompensation::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyCompensation.stamp)
  return _internal_stamp();
}
inline void LatencyCompensation::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LatencyCompensation.stamp)
}
inline ::fsm::proto::Timestamp* LatencyCompensation::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* LatencyCompensation::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.LatencyCompensation.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* LatencyCompensation::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* LatencyCompensation::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LatencyCompensation.stamp)
  return _internal_mutable_stamp();
}
inline void LatencyCompensation::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LatencyCompensation.stamp)
}

// float compensation_time = 2;
inline void LatencyCompensation::clear_compensation_time() {
  compensation_time_ = 0;
}
inline float LatencyCompensation::_internal_compensation_time() const {
  return compensation_time_;
}
inline float LatencyCompensation::compensation_time() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyCompensation.compensation_time)
  return _internal_compensation_time();
}
inline void LatencyCompensation::_internal_set_compensation_time(float value) {
  
  compensation_time_ = value;
}
inline void LatencyCompensation::set_compensation_time(float value) {
  _internal_set_compensation_time(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyCompensation.compensation_time)
}

// .fsm.proto.PredictedTrajectory predicted = 3;
inline bool LatencyCompensation::_internal_has_predicted() const {
  return this != internal_default_instance() && predicted_ != nullptr;
}
inline bool LatencyCompensation::has_predicted() const {
  return _internal_has_predicted();
}
inline void LatencyCompensation::clear_predicted() {
  if (GetArena() == nullptr && predicted_ != nullptr) {
    delete predicted_;
  }
  predicted_ = nullptr;
}
inline const ::fsm::proto::PredictedTrajectory& LatencyCompensation::_internal_predicted() const {
  const ::fsm::proto::PredictedTrajectory* p = predicted_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::PredictedTrajectory*>(
      &::fsm::proto::_PredictedTrajectory_default_instance_);
}
inline const ::fsm::proto::PredictedTrajectory& LatencyCompensation::predicted() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyCompensation.predicted)
  return _internal_predicted();
}
inline void LatencyCompensation::unsafe_arena_set_allocated_predicted(
    ::fsm::proto::PredictedTrajectory* predicted) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicted_);
  }
  predicted_ = predicted;
  if (predicted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.LatencyCompensation.predicted)
}
inline ::fsm::proto::PredictedTrajectory* LatencyCompensation::release_predicted() {
  auto temp = unsafe_arena_release_predicted();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::PredictedTrajectory* LatencyCompensation::unsafe_arena_release_predicted() {
  // @@protoc_insertion_point(field_release:fsm.proto.LatencyCompensation.predicted)
  
  ::fsm::proto::PredictedTrajectory* temp = predicted_;
  predicted_ = nullptr;
  return temp;
}
inline ::fsm::proto::PredictedTrajectory* LatencyCompensation::_internal_mutable_predicted() {
  
  if (predicted_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::PredictedTrajectory>(GetArena());
    predicted_ = p;
  }
  return predicted_;
}
inline ::fsm::proto::PredictedTrajectory* LatencyCompensation::mutable_predicted() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.LatencyCompensation.predicted)
  return _internal_mutable_predicted();
}
inline void LatencyCompensation::set_allocated_predicted(::fsm::proto::PredictedTrajectory* predicted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete predicted_;
  }
  if (predicted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(predicted);
    if (message_arena != submessage_arena) {
      predicted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicted, submessage_arena);
    }
    
  } else {
    
  }
  predicted_ = predicted;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.LatencyCompensation.predicted)
}

// bool enabled = 4;
inline void LatencyCompensation::clear_enabled() {
  enabled_ = false;
}
inline bool LatencyCompensation::_internal_enabled() const {
  return enabled_;
}
inline bool LatencyCompensation::enabled() const {
  // @@protoc_insertion_point(field_get:fsm.proto.LatencyCompensation.enabled)
  return _internal_enabled();
}
inline void LatencyCompensation::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void LatencyCompensation::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:fsm.proto.LatencyCompensation.enabled)
}

// -------------------------------------------------------------------

// VideoFrameMetadata

// .fsm.proto.Timestamp stamp = 1;
inline bool VideoFrameMetadata::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool VideoFrameMetadata::has_stamp() const {
  return _internal_has_stamp();
}
inline void VideoFrameMetadata::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& VideoFrameMetadata::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& VideoFrameMetadata::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.stamp)
  return _internal_stamp();
}
inline void VideoFrameMetadata::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VideoFrameMetadata.stamp)
}
inline ::fsm::proto::Timestamp* VideoFrameMetadata::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* VideoFrameMetadata::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.VideoFrameMetadata.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* VideoFrameMetadata::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* VideoFrameMetadata::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VideoFrameMetadata.stamp)
  return _internal_mutable_stamp();
}
inline void VideoFrameMetadata::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VideoFrameMetadata.stamp)
}

// string camera_id = 2;
inline void VideoFrameMetadata::clear_camera_id() {
  camera_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoFrameMetadata::camera_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.camera_id)
  return _internal_camera_id();
}
inline void VideoFrameMetadata::set_camera_id(const std::string& value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.camera_id)
}
inline std::string* VideoFrameMetadata::mutable_camera_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VideoFrameMetadata.camera_id)
  return _internal_mutable_camera_id();
}
inline const std::string& VideoFrameMetadata::_internal_camera_id() const {
  return camera_id_.Get();
}
inline void VideoFrameMetadata::_internal_set_camera_id(const std::string& value) {
  
  camera_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoFrameMetadata::set_camera_id(std::string&& value) {
  
  camera_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.VideoFrameMetadata.camera_id)
}
inline void VideoFrameMetadata::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  camera_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.VideoFrameMetadata.camera_id)
}
inline void VideoFrameMetadata::set_camera_id(const char* value,
    size_t size) {
  
  camera_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.VideoFrameMetadata.camera_id)
}
inline std::string* VideoFrameMetadata::_internal_mutable_camera_id() {
  
  return camera_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoFrameMetadata::release_camera_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.VideoFrameMetadata.camera_id)
  return camera_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoFrameMetadata::set_allocated_camera_id(std::string* camera_id) {
  if (camera_id != nullptr) {
    
  } else {
    
  }
  camera_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camera_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VideoFrameMetadata.camera_id)
}
inline std::string* VideoFrameMetadata::unsafe_arena_release_camera_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.VideoFrameMetadata.camera_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return camera_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoFrameMetadata::unsafe_arena_set_allocated_camera_id(
    std::string* camera_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (camera_id != nullptr) {
    
  } else {
    
  }
  camera_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      camera_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VideoFrameMetadata.camera_id)
}

// uint32 width = 3;
inline void VideoFrameMetadata::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameMetadata::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameMetadata::width() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.width)
  return _internal_width();
}
inline void VideoFrameMetadata::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void VideoFrameMetadata::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.width)
}

// uint32 height = 4;
inline void VideoFrameMetadata::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameMetadata::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameMetadata::height() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.height)
  return _internal_height();
}
inline void VideoFrameMetadata::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void VideoFrameMetadata::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.height)
}

// string encoding = 5;
inline void VideoFrameMetadata::clear_encoding() {
  encoding_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoFrameMetadata::encoding() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.encoding)
  return _internal_encoding();
}
inline void VideoFrameMetadata::set_encoding(const std::string& value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.encoding)
}
inline std::string* VideoFrameMetadata::mutable_encoding() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.VideoFrameMetadata.encoding)
  return _internal_mutable_encoding();
}
inline const std::string& VideoFrameMetadata::_internal_encoding() const {
  return encoding_.Get();
}
inline void VideoFrameMetadata::_internal_set_encoding(const std::string& value) {
  
  encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoFrameMetadata::set_encoding(std::string&& value) {
  
  encoding_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.VideoFrameMetadata.encoding)
}
inline void VideoFrameMetadata::set_encoding(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.VideoFrameMetadata.encoding)
}
inline void VideoFrameMetadata::set_encoding(const char* value,
    size_t size) {
  
  encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.VideoFrameMetadata.encoding)
}
inline std::string* VideoFrameMetadata::_internal_mutable_encoding() {
  
  return encoding_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoFrameMetadata::release_encoding() {
  // @@protoc_insertion_point(field_release:fsm.proto.VideoFrameMetadata.encoding)
  return encoding_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoFrameMetadata::set_allocated_encoding(std::string* encoding) {
  if (encoding != nullptr) {
    
  } else {
    
  }
  encoding_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoding,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.VideoFrameMetadata.encoding)
}
inline std::string* VideoFrameMetadata::unsafe_arena_release_encoding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.VideoFrameMetadata.encoding)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return encoding_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoFrameMetadata::unsafe_arena_set_allocated_encoding(
    std::string* encoding) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (encoding != nullptr) {
    
  } else {
    
  }
  encoding_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      encoding, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.VideoFrameMetadata.encoding)
}

// uint64 frame_number = 6;
inline void VideoFrameMetadata::clear_frame_number() {
  frame_number_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VideoFrameMetadata::_internal_frame_number() const {
  return frame_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VideoFrameMetadata::frame_number() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.frame_number)
  return _internal_frame_number();
}
inline void VideoFrameMetadata::_internal_set_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_number_ = value;
}
inline void VideoFrameMetadata::set_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_number(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.frame_number)
}

// float fps = 7;
inline void VideoFrameMetadata::clear_fps() {
  fps_ = 0;
}
inline float VideoFrameMetadata::_internal_fps() const {
  return fps_;
}
inline float VideoFrameMetadata::fps() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.fps)
  return _internal_fps();
}
inline void VideoFrameMetadata::_internal_set_fps(float value) {
  
  fps_ = value;
}
inline void VideoFrameMetadata::set_fps(float value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.fps)
}

// uint32 bitrate = 8;
inline void VideoFrameMetadata::clear_bitrate() {
  bitrate_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameMetadata::_internal_bitrate() const {
  return bitrate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoFrameMetadata::bitrate() const {
  // @@protoc_insertion_point(field_get:fsm.proto.VideoFrameMetadata.bitrate)
  return _internal_bitrate();
}
inline void VideoFrameMetadata::_internal_set_bitrate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  bitrate_ = value;
}
inline void VideoFrameMetadata::set_bitrate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:fsm.proto.VideoFrameMetadata.bitrate)
}

// -------------------------------------------------------------------

// Heartbeat

// .fsm.proto.Timestamp stamp = 1;
inline bool Heartbeat::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool Heartbeat::has_stamp() const {
  return _internal_has_stamp();
}
inline void Heartbeat::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& Heartbeat::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& Heartbeat::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Heartbeat.stamp)
  return _internal_stamp();
}
inline void Heartbeat::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Heartbeat.stamp)
}
inline ::fsm::proto::Timestamp* Heartbeat::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* Heartbeat::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.Heartbeat.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* Heartbeat::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* Heartbeat::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Heartbeat.stamp)
  return _internal_mutable_stamp();
}
inline void Heartbeat::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Heartbeat.stamp)
}

// string sender_id = 2;
inline void Heartbeat::clear_sender_id() {
  sender_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Heartbeat::sender_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Heartbeat.sender_id)
  return _internal_sender_id();
}
inline void Heartbeat::set_sender_id(const std::string& value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Heartbeat.sender_id)
}
inline std::string* Heartbeat::mutable_sender_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.Heartbeat.sender_id)
  return _internal_mutable_sender_id();
}
inline const std::string& Heartbeat::_internal_sender_id() const {
  return sender_id_.Get();
}
inline void Heartbeat::_internal_set_sender_id(const std::string& value) {
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Heartbeat::set_sender_id(std::string&& value) {
  
  sender_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.Heartbeat.sender_id)
}
inline void Heartbeat::set_sender_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.Heartbeat.sender_id)
}
inline void Heartbeat::set_sender_id(const char* value,
    size_t size) {
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.Heartbeat.sender_id)
}
inline std::string* Heartbeat::_internal_mutable_sender_id() {
  
  return sender_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Heartbeat::release_sender_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.Heartbeat.sender_id)
  return sender_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Heartbeat::set_allocated_sender_id(std::string* sender_id) {
  if (sender_id != nullptr) {
    
  } else {
    
  }
  sender_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.Heartbeat.sender_id)
}
inline std::string* Heartbeat::unsafe_arena_release_sender_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.Heartbeat.sender_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return sender_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Heartbeat::unsafe_arena_set_allocated_sender_id(
    std::string* sender_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sender_id != nullptr) {
    
  } else {
    
  }
  sender_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sender_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.Heartbeat.sender_id)
}

// uint64 sequence = 3;
inline void Heartbeat::clear_sequence() {
  sequence_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Heartbeat::_internal_sequence() const {
  return sequence_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Heartbeat::sequence() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Heartbeat.sequence)
  return _internal_sequence();
}
inline void Heartbeat::_internal_set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_ = value;
}
inline void Heartbeat::set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Heartbeat.sequence)
}

// bool request_ack = 4;
inline void Heartbeat::clear_request_ack() {
  request_ack_ = false;
}
inline bool Heartbeat::_internal_request_ack() const {
  return request_ack_;
}
inline bool Heartbeat::request_ack() const {
  // @@protoc_insertion_point(field_get:fsm.proto.Heartbeat.request_ack)
  return _internal_request_ack();
}
inline void Heartbeat::_internal_set_request_ack(bool value) {
  
  request_ack_ = value;
}
inline void Heartbeat::set_request_ack(bool value) {
  _internal_set_request_ack(value);
  // @@protoc_insertion_point(field_set:fsm.proto.Heartbeat.request_ack)
}

// -------------------------------------------------------------------

// HeartbeatAck

// .fsm.proto.Timestamp stamp = 1;
inline bool HeartbeatAck::_internal_has_stamp() const {
  return this != internal_default_instance() && stamp_ != nullptr;
}
inline bool HeartbeatAck::has_stamp() const {
  return _internal_has_stamp();
}
inline void HeartbeatAck::clear_stamp() {
  if (GetArena() == nullptr && stamp_ != nullptr) {
    delete stamp_;
  }
  stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& HeartbeatAck::_internal_stamp() const {
  const ::fsm::proto::Timestamp* p = stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& HeartbeatAck::stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.HeartbeatAck.stamp)
  return _internal_stamp();
}
inline void HeartbeatAck::unsafe_arena_set_allocated_stamp(
    ::fsm::proto::Timestamp* stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stamp_);
  }
  stamp_ = stamp;
  if (stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.HeartbeatAck.stamp)
}
inline ::fsm::proto::Timestamp* HeartbeatAck::release_stamp() {
  auto temp = unsafe_arena_release_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* HeartbeatAck::unsafe_arena_release_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.HeartbeatAck.stamp)
  
  ::fsm::proto::Timestamp* temp = stamp_;
  stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* HeartbeatAck::_internal_mutable_stamp() {
  
  if (stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    stamp_ = p;
  }
  return stamp_;
}
inline ::fsm::proto::Timestamp* HeartbeatAck::mutable_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.HeartbeatAck.stamp)
  return _internal_mutable_stamp();
}
inline void HeartbeatAck::set_allocated_stamp(::fsm::proto::Timestamp* stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stamp_;
  }
  if (stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stamp);
    if (message_arena != submessage_arena) {
      stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stamp, submessage_arena);
    }
    
  } else {
    
  }
  stamp_ = stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.HeartbeatAck.stamp)
}

// string sender_id = 2;
inline void HeartbeatAck::clear_sender_id() {
  sender_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HeartbeatAck::sender_id() const {
  // @@protoc_insertion_point(field_get:fsm.proto.HeartbeatAck.sender_id)
  return _internal_sender_id();
}
inline void HeartbeatAck::set_sender_id(const std::string& value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:fsm.proto.HeartbeatAck.sender_id)
}
inline std::string* HeartbeatAck::mutable_sender_id() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.HeartbeatAck.sender_id)
  return _internal_mutable_sender_id();
}
inline const std::string& HeartbeatAck::_internal_sender_id() const {
  return sender_id_.Get();
}
inline void HeartbeatAck::_internal_set_sender_id(const std::string& value) {
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HeartbeatAck::set_sender_id(std::string&& value) {
  
  sender_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fsm.proto.HeartbeatAck.sender_id)
}
inline void HeartbeatAck::set_sender_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fsm.proto.HeartbeatAck.sender_id)
}
inline void HeartbeatAck::set_sender_id(const char* value,
    size_t size) {
  
  sender_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fsm.proto.HeartbeatAck.sender_id)
}
inline std::string* HeartbeatAck::_internal_mutable_sender_id() {
  
  return sender_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HeartbeatAck::release_sender_id() {
  // @@protoc_insertion_point(field_release:fsm.proto.HeartbeatAck.sender_id)
  return sender_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HeartbeatAck::set_allocated_sender_id(std::string* sender_id) {
  if (sender_id != nullptr) {
    
  } else {
    
  }
  sender_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.HeartbeatAck.sender_id)
}
inline std::string* HeartbeatAck::unsafe_arena_release_sender_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fsm.proto.HeartbeatAck.sender_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return sender_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HeartbeatAck::unsafe_arena_set_allocated_sender_id(
    std::string* sender_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sender_id != nullptr) {
    
  } else {
    
  }
  sender_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sender_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.HeartbeatAck.sender_id)
}

// uint64 sequence = 3;
inline void HeartbeatAck::clear_sequence() {
  sequence_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeartbeatAck::_internal_sequence() const {
  return sequence_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HeartbeatAck::sequence() const {
  // @@protoc_insertion_point(field_get:fsm.proto.HeartbeatAck.sequence)
  return _internal_sequence();
}
inline void HeartbeatAck::_internal_set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_ = value;
}
inline void HeartbeatAck::set_sequence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:fsm.proto.HeartbeatAck.sequence)
}

// .fsm.proto.Timestamp original_stamp = 4;
inline bool HeartbeatAck::_internal_has_original_stamp() const {
  return this != internal_default_instance() && original_stamp_ != nullptr;
}
inline bool HeartbeatAck::has_original_stamp() const {
  return _internal_has_original_stamp();
}
inline void HeartbeatAck::clear_original_stamp() {
  if (GetArena() == nullptr && original_stamp_ != nullptr) {
    delete original_stamp_;
  }
  original_stamp_ = nullptr;
}
inline const ::fsm::proto::Timestamp& HeartbeatAck::_internal_original_stamp() const {
  const ::fsm::proto::Timestamp* p = original_stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fsm::proto::Timestamp*>(
      &::fsm::proto::_Timestamp_default_instance_);
}
inline const ::fsm::proto::Timestamp& HeartbeatAck::original_stamp() const {
  // @@protoc_insertion_point(field_get:fsm.proto.HeartbeatAck.original_stamp)
  return _internal_original_stamp();
}
inline void HeartbeatAck::unsafe_arena_set_allocated_original_stamp(
    ::fsm::proto::Timestamp* original_stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_stamp_);
  }
  original_stamp_ = original_stamp;
  if (original_stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fsm.proto.HeartbeatAck.original_stamp)
}
inline ::fsm::proto::Timestamp* HeartbeatAck::release_original_stamp() {
  auto temp = unsafe_arena_release_original_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fsm::proto::Timestamp* HeartbeatAck::unsafe_arena_release_original_stamp() {
  // @@protoc_insertion_point(field_release:fsm.proto.HeartbeatAck.original_stamp)
  
  ::fsm::proto::Timestamp* temp = original_stamp_;
  original_stamp_ = nullptr;
  return temp;
}
inline ::fsm::proto::Timestamp* HeartbeatAck::_internal_mutable_original_stamp() {
  
  if (original_stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::fsm::proto::Timestamp>(GetArena());
    original_stamp_ = p;
  }
  return original_stamp_;
}
inline ::fsm::proto::Timestamp* HeartbeatAck::mutable_original_stamp() {
  // @@protoc_insertion_point(field_mutable:fsm.proto.HeartbeatAck.original_stamp)
  return _internal_mutable_original_stamp();
}
inline void HeartbeatAck::set_allocated_original_stamp(::fsm::proto::Timestamp* original_stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete original_stamp_;
  }
  if (original_stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(original_stamp);
    if (message_arena != submessage_arena) {
      original_stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, original_stamp, submessage_arena);
    }
    
  } else {
    
  }
  original_stamp_ = original_stamp;
  // @@protoc_insertion_point(field_set_allocated:fsm.proto.HeartbeatAck.original_stamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace fsm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::fsm::proto::ConnectionStatus_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::ConnectionStatus_State>() {
  return ::fsm::proto::ConnectionStatus_State_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::GearPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::GearPosition>() {
  return ::fsm::proto::GearPosition_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::VehicleMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::VehicleMode>() {
  return ::fsm::proto::VehicleMode_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::TurnSignal> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::TurnSignal>() {
  return ::fsm::proto::TurnSignal_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::DiagnosticLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::DiagnosticLevel>() {
  return ::fsm::proto::DiagnosticLevel_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::VehicleTaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::VehicleTaskStatus>() {
  return ::fsm::proto::VehicleTaskStatus_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::EmergencyLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::EmergencyLevel>() {
  return ::fsm::proto::EmergencyLevel_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::AlertSeverity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::AlertSeverity>() {
  return ::fsm::proto::AlertSeverity_descriptor();
}
template <> struct is_proto_enum< ::fsm::proto::AlertType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fsm::proto::AlertType>() {
  return ::fsm::proto::AlertType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fsm_5fmessages_2eproto
